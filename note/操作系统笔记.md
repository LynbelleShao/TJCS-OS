# 第一章 绪论

计算机组成：输入、输出、内存、中央处理器CPU

计算机系统自下而上：硬件、操作系统、应用程序、用户

计算机组成的四部分都属于硬件（计算机组成原理课程所学）

操作系统保证了程序可以在CPU上高效的执行

磁盘就是电脑上的C盘D盘。

硬盘属于输出设备。

磁盘上的一段程序代码如何运行? （也正是操作系统四大功能）

1. 文件管理：通过文件名定位磁盘文件 
   - 文件的按名存取 
   - 文件逻辑地址和物理地址的转换
2. 内存管理：合理组织分配内存空间什么时候进内存？ 
   - 进到内存什么地方？ 
   - 内存不够大怎么办？
3. 设备管理：程序代码如何进入内存怎么读入内存？ 
   - 内存快，外存慢，怎么解决？ 
   - 外存和内存地址如何转换？
4. 处理机管理：合理组织和调度CPU什么时候可以在CPU上执行？ 
   - 需要和哪些进程共享CPU？

<img src=".\assets\image-20241026150643082.png" alt="image-20241026150643082" style="zoom:50%;" />

## 设置操作系统的目的

操作系统的重要地位：

1. 组织和管理系统中的软硬件资源；
2. 向应用程序提供高质量的服务； 
3. 为用户提供易于理解和编程的接口

## 操作系统的形成和发展

#### 无操作系统的计算机系统

##### 联机输入输出方式

联机指的是在主机控制下输入输出。

人工操作方式：用户独占全机，CPU等待人工操作。→ 人机矛盾

##### 脱机输入输出方式

时代背景：晶体管线路计算机。

程序和数据的输入和输出都是在外围机的控制下完成的，它们是在脱离主机的情况下进行的。主机不负责IO

<img src=".\assets\image-20241026151415721.png" alt="image-20241026151415721" style="zoom:33%;" />

#### 批处理系统

批处理技术 ：一批作业由输入机以脱机方式输入到磁带，监控程序（可以看做操作系统的雏形） 按顺序依次将作业调入内存执行。

##### 单道批处理系统

时代背景：计算机性能提升，可靠性增强，开发出汇编语言、高级语言，出现系统程序。

作业处理成批进行，**内存中只驻留一道作业**。

自动、顺序、单道。

##### 多道批处理系统

时代背景：集成电路计算机。

自动、并发、多道。

用户提交的作业形成后备队列， 作业调度程序选择若干作业调入内存。调度程序负责选择一个适于执行的作业，完成CPU在作业之间的切换。

<img src=".\assets\image-20241026152041516.png" alt="image-20241026152041516" style="zoom: 67%;" />

调度程序的调度算法也是需要时间的。

提交的一个作业应该包含：作业说明书（也叫作业控制信息，计算机根据这个去执行，无法交互），程序，数据。

多道性：计算机内存中同时存在多个相互独立的程序；

 宏观上并发执行：同时进入系统的几道程序都处于运行状态； 

微观上串行执行：各作业交替使用CPU。

优点：提高CPU利用率，系统吞吐量大。（吞吐量是单位时间CPU完成作业的数量）

缺点：平均周转时间长（多道之后有了就绪等待的状态），无交互能力（无调试功能）。

采用多道程序设计技术能充分发挥CPU和外设并行工作的能力。

<img src=".\assets\image-20241026152614337.png" alt="image-20241026152614337" style="zoom:67%;" />

#### 分时操作系统

一台主机连接了若干个终端，每个终端有一个用户在使用。用户交互式地向系统提出命令请求，系统接受每个用户的命令，采用**时间片轮转方式**处理服务请求，并通过交互方式在终端上向用户显示结果。

人机交互、共享主机。

作业直接进入内存。

分时系统具有独占性，指的是用户感觉自己在使用整个系统，不是真正的独占。

分时系统的响应时间好。（时间片轮转使得每个任务在较短的时间内得到响应，提高用户满意度）

#### 微机操作系统

<img src=".\assets\image-20241026152806643.png" alt="image-20241026152806643" style="zoom:50%;" />

UNIX是分时系统，LINUX是UNIX的变型。

**多用户分时系统是如今最普遍的。**

现代操作系统都是多任务的，多任务操作系统具有并发和并行的特点，指的是进程之间并发，cpu与外设之间并行。



**操作系统发展的主要推动力：** 

1. 不断提高计算机资源的利用率； 
2.  方便用户 
3. 器件的不断更新换代 
4. 计算机体系结构的不断发展



**操作系统类型**

1. 批处理操作系统：**系统效率、吞吐量**（无交互能力）（批处理作业）
2. 分时操作系统：多路性、**交互性**、独占性（交互性极强、不太及时、可靠程度较低）（交互式作业）
3. 实时操作系统：**及时性、可靠性**（专用系统、简单交互性、高可靠性）（实时作业）

如果兼有2项以上操作系统的功能，叫通用操作系统。

:star2:实时操作系统的最重要两个目标是实时性和可靠性，资源利用率不是实时操作系统的主要目标，为了保证快速处理高优先级的任务，允许“浪费”一些系统资源。

:star2:实时操作系统要求在特定的时间内完成特定的功能，批处理不要求在响应时间内处理完成一个任务，分时操作系统不要求在周转时间或调度时间内处理完成外部事件。

:star2:实时系统的进程调度不是使用时间片，而是应该采用抢占式的优先级高者优先算法。分时操作系统才是用时间片轮转调度。



## 现代操作系统的功能与特征 

操作系统功能：处理机管理、存储器管理、设备管理、文件管理、用户接口。

操作系统四大特性：

1. 异步性（不确定性）：走走停停，不可再现。

   异步性使得操作系统运行在一中随机的环境下，可能导致进程产生与时间有关的错误。然而，只要运行环境相同，操作系统就需要保证多次运行进程后都能获得相同的结果。

2. 共享性：同时，互斥。

   共享指的是系统重所有进程共享系统资源。同时是多个用户同时在用；

   互斥是某一时刻仅运行一个进程访问临界资源。

3. 虚拟性：物理、逻辑。

   虚拟包括处理器、存储器和外部设备。

4. 并发性：并发/并行，程序/进程。

   并发是同一时间间隔→单核调度（软件）

   并行是同一时刻→多核CPU（硬件）

   所以单处理机系统只能并发执行，不能并行执行。

   程序是指令的集合，进程是一次执行过程，是运行中的程序。

   **进程是在多道环境下资源分配的基本单位。**

共享性和并发性是两个最基本特征，互为存在条件。资源共享以进程并发为条件；程序并发执行以资源共享为前提。

:star2:在多道程序环境下，并发性指的是一段时间内，宏观上有多个程序同时进行，但在单处理器系统中每个时刻仅有一道程序执行，微观上是分时交替进行；若多处理器则是并行执行。



## UNIX操作系统

**UNIX系统的特点**

1. 精巧的核心与丰富的实用层 

   内核 ：进程管理、存储管理、设备管理、文件管理等。内核设计精干简洁。只占用很小的内存并常驻内存。 

   核外程序 ：语言处理程序、编辑程序、调试程序、系统状态监控和文件管理程序、命令解释程序shell。 

2. 使用灵活的用户界面 

   命令程序设计语言 Shell：是一种命令语言，也是一种程序设计语言。 

   程序接口 ：即：系统调用，包括汇编语言和C语言的。 

3. 树形结构的文件系统 

4. 文件和设备统一看待 

5. 良好的移植性

**UNIX系统的结构**

<img src=".\assets\微信图片_20241026155410.jpg" style="zoom:67%;" />



## 补充

操作系统定义：操作系统是计算机系统中的一个**系统软件**，它是一组用以控制、管理**计算机系统中软硬件资源**（基本功能），提供资源管理效率，方便用户使用计算机的程序集合。

是最基本的系统软件。

从一般用户角度：操作系统在计算机和用户之间起到接口的作用；

从资源管理角度：操作系统是计算机系统资源的管理者。

用户通过接口来取得操作系统的服务：命令接口和程序接口。

- 命令接口（作业控制）
  - 联机用户接口：联机用户、键盘
  - 脱机用户接口：批处理用户、作业说明书

- 程序接口（系统调用）

  是用户程序取得操作系统服务的唯一途径。

  由一组系统调用组成。

  - 早期的系统调用是汇编写的，但在高级语言中提供了与各系统调用一一对应的库函数。（库函数是用户程序而非系统调用，是系统调用的上一层）

  - 现在的系统调用本身已经采用c语言编写并以函数形式提供。

现在发展出图形用户接口（图形用户接口调用了系统调用而实现的功能，但其不属于命令接口，图形接口与命令接口、程序接口无从属关系）

# 第二章 并发进程

## 进程基本概念

多道程序环境下，操作系统分配资源以**进程**为基本单位。所以操作系统的“处理机管理”功能可归结为“进程管理”。

程序和进程的本质区别是**动态和静态特征**。

程序是静态的，存放在某种介质上。

程序顺序执行时有顺序性、封闭性、可再现性的特点。

进程具有动态性 ，具有生命周期， “由创建而产生，由调度而执行，由撤销而消亡”。（并发进程可能因为等待资源或被抢占CPU而暂停运行，所以生命周期不连续）

进程的特征：动态性、并发性、异步性（不确定性）。

:star2:为什么要引入进程？

在多道程序设计背景下，进程之间需要共享系统资源，程序这个静态概念已经不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好的支持和管理多道程序的并发执行，引入了进程的概念。

一个进程实体包括程序段、相关数据段和PCB三部分组成。

一个进程可以顺序执行一个或多个程序，但不能同时执行多个程序 。

一个程序的多次运行可以形成多个不同的进程。一个程序的一次运行可以产生多个进程。

**操作系统最重要的记录型数据结构是 PCB。**

操作系统所需的、用于描述进程的当前状况以及控制进程运行的全部信息都在PCB里。

每一个进程都有一个PCB。

**PCB是进程存在的唯一标志。**

PCB组织方式：链接和索引两种。

<img src=".\assets\image-20241026162945708.png" alt="image-20241026162945708" style="zoom:50%;" />

### 进程的状态与调度

进程的三种状态：

1. 执行状态（当前正在使用CPU）
2. 就绪状态（可运行；但CPU被占用，暂时无法运行）
3. 阻塞状态（无法运行，直到某一外部事件发生）

:star2:在任何题目中，进程都只有这三种状态。

一个CPU某个时刻只有1个执行状态的进程。最多1个，也可以为0，因为都阻塞。

当执行状态进程数=0时，就绪状态进程数 一定=0.

在任何时候，一个系统中现运行进程的个数≤处理机的个数。

<img src=".\assets\image-20241026163707856.png" alt="image-20241026163707856" style="zoom:67%;" />

#### 进程上台下台

<img src=".\assets\image-20241026163943790.png" alt="image-20241026163943790" style="zoom:67%;" />

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20241026164004950.png" alt="image-20241026164004950" style="zoom:67%;" />

#### 进程的阻塞与唤醒

<img src=".\assets\image-20241026164117730.png" alt="image-20241026164117730" style="zoom:67%;" />

进程一定不是自己醒的，一定是被其他进程唤醒的。

#### 引入挂起状态

<img src=".\assets\image-20241026164257872.png" alt="image-20241026164257872" style="zoom:67%;" />

#### 引入创建状态 

作业调度（高级调度）指的是作业从后备队列被选入内存。作业是在这时才创建进程的。

提供服务是指系统处理用户程序的请求（我觉得：命令接口），应用请求是指用户程序的应用请求（我觉得：程序接口）。

进程创建时，如果没有空白PCB，则申请失败，创建失败。

如果在为进程分配资源（内存空间）时资源不足，不是创建失败，是处于创建态等待内存资源。

父进程一定在内存里，但创建子进程：

​	内存空间有余，则子进程活动就绪；

​	内存空间无空余，则子进程静止就绪。

#### 引入终止状态

<img src=".\assets\image-20241026164731288.png" alt="image-20241026164731288" style="zoom:67%;" />

进程控制原语：创建create、撤销terminate、阻塞block、唤醒wake up、挂起suspend、激活active

## 处理机调度

处理机调度的分类：

**作业调度（高级调度）**：从后备队列选一个（单道）/多个（多道）作业调入内存，创建进程，分配资源，如创建成功，将新创建的进程插入就绪队列。

**进程调度（低级调度）**：从就绪队列选择一个为之分配处理机。

**内存调度（中级调度）**：引入挂起（为了**节省内存**，把内存中处于阻塞或者长期不运行的进程挂起到外存），有了静止就绪和静止阻塞队列。

级别越低频率越高，进程调度是最基本的，不可或缺。

具有一级调度的调度队列模型：作业调度

具有二级调度的调度队列模型：作业调度、进程调度

具有三级调度的调度队列模型：作业调度、进程调度、内存调度



处理机调度要考虑的因素：

1. 调度本身的开销 （调度算法时间复杂度）
2. 相关数据结构的维护 （调度算法空间复杂度）
3. 各种不同的调度对象：I/O密集型，CPU密集型，长作业，短作业



选择调度方式和调度算法的若干准则：

1. 周转时间短：批处理型作业 
2. 响应速度快：交互型作业 
3. 高优先权优先
4. 截至时间保证：实时型作业

:star2:周转时间= 作业完成时间–作业提交时间 

​                     = 作业运行时间+ 作业等待（后备）时间

:star2:计算进程调度次数时要注意，0时刻进程上台也是一次进程调度。

### 调度算法

#### 先来先服务算法（FIFO）

非抢占。

缺点：

1.  长作业有利（因为它可以一直执行不被赶下台），短作业吃亏（因为短作业本来很快就能完成，却因为来得晚只能漫长的等待） 
2. CPU密集型作业有利（因为它可以一直执行不被赶下台），I/O密集型作业吃亏（因为它每次阻塞之后都会到就绪队列的队尾）

#### 短作业/进程优先（SJ/PF）

非抢占（是在挑选进程时选择最短的，而不是抢占，进程一旦开始执行就不可更改）和抢占都有。

**当所有作业同时到达时，平均周转时间/等待时间最短的调度算法是短作业优先算法。**

缺点： 

1. 短作业有利，长作业吃亏； 
2. 未考虑作业的紧迫程度。

**抢占式改进：最短剩余时间优先。**

<img src=".\assets\image-20241026182215734.png" alt="image-20241026182215734" style="zoom:67%;" />

指的是每当有新进程到来时，比较当前台上进程剩余时间和新来进程的总时长，如果新来进程的总时长更小，就让新来进程上台。

就绪等待队列是FIFO的，即，当两个就绪进程剩余时间最短且相等时，选择队列中位置更靠前的那个。

#### 时间片轮转调度算法（RR）

抢占。（是绝对可抢占，短作业优先和优先权调度算法都是有抢占和不抢占两种）

交互式系统（分时系统）中的进程调度：每个进程轮流使用CPU固定时间片后将CPU让给其它进程，自己进入就绪队列等待下一轮调度。

优点：各进程能够比较均衡地共享使用处理机。

缺点：**系统的效率与时间片的设置密切相关**。时间片过大，与用户的**交互性**就差； 时间片过小，进程间切换过于频繁，一个进程需要轮转多次才能到达终点，系统开销就会增大。

对进程响应时间造成影响的因素：时间片值的选取、交互进程的数量。

<img src=".\assets\image-20241026183133049.png" alt="image-20241026183133049" style="zoom:67%;" />

注意，就绪队列是FIFO，同一时刻，新来的进程排在刚下台的进程前面。

每次选取上台进程都是选择就绪队列的队首。

#### 最高优先权优先调度算法（FPF）

多数操作系统中采用的进程调度算法。

非抢占和抢占都有。

非抢占：进程一直运行到完成；或发生某事件而阻塞，系统将处理机分配给另一个优先级最高的进程。（批处理系统、要求不高的实时系统）

抢占：进程执行中，调度程序可随时停止其执行，将处理机分配给新出现的优先级更高的进程。（实时系统、交互系统）

:star2:进程终止和阻塞时进行进程切换都叫非抢占。所以非抢占≠单道。单道是终止才换，非抢占是终止和阻塞都换。

优先级设置原则：

系统进程>用户进程

交互型进程>非交互型进程（交互型需要更多时间，优先级高能让它早点开始）

IO型进程>计算型进程（IO型需要更多时间，优先级高能让它早点开始以提升整体效率）

##### 静态优先权

创建进程时确定，且进程的整个运行期间保持不变。

优点：简单，不需要维护优先权。 

缺点：高者恒高，不断地有高者转为就绪的话，低者将会“饥饿”。

<img src=".\assets\image-20241026190359926.png" alt="image-20241026190359926" style="zoom:67%;" />

<img src=".\assets\image-20241026190415569.png" alt="image-20241026190415569" style="zoom:67%;" />

:star2:在这道题目中，35的时刻有一点点问题，c进程阻塞被唤醒并例行调度重新上台和b进程因阻塞而下台发生在了同一秒。假设b进程早一秒进入阻塞，那么会是a进程上台执行一秒，然后在1秒后由于c的优先级更高被抢占调度；假设b进程晚一秒进入阻塞，那么唤醒c的就是台上进程b，c是抢占调度上台。

##### 动态优先权

系统为刚生成的进程赋初始优先权，之后根据进程的行为动态调整优先权的值。

防止高者恒高， 低者“饥饿”。

调整原则：正在使用CPU的进程优先级下降；很久未得到CPU的进程优先级升高；I/O密集型进程拥有较高的优先权。

调整时机：间隔太短，开销太大；间隔太长，不能及时反映变化。一般选择**调度、时钟中断、陷入**等时机调整。

:star2:不会出现饥饿现象的调度算法：时间片轮转、动态优先调度。

## 死锁

<img src=".\assets\image-20241026190653495.png" alt="image-20241026190653495" style="zoom:67%;" />

（还有一种表示是方块里面有小圆圈，指的是资源的个数）

死锁：一个进程集合中的每个进程都等待着永远都不会发生的事件而形成一种永久阻塞状态。

死锁可以通过有向图来建模：形成环路。

### 死锁产生的原因

1. 资源竞争引起资源死锁 

   资源分为可剥夺资源和不可剥夺资源，对不可剥夺资源的竞争使用可能导致死锁 

2. 进程推进顺序不当造成死锁

### 死锁产生的必要条件

注意：是必要条件，满足不一定就死锁。

:star2:有环路，只是满足死锁的必要条件，不一定会出现死锁。如果有环路且每种资源只有一个，这就是死锁的充分条件，一定会出现死锁。没有环路，不满足死锁的必要条件，所以一定没有死锁。

1. 互斥条件 ：即在一段时间能**某资源只能由一个进程占用**。如果此时还有其他进程请求使用该资源，则请求者只能等待，直至占用该资源的进程用毕释放。 
2. 请求和保持条件 ：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其他进程占用，此时请求进程阻塞，**但又对自己已获得的其他资源保持不放**。 
3. 不剥夺条件 ：指进程已获得的资源，**在未使用完之前，不能被剥夺**，只能在使用完后由自己释放。 
4. 环路等待条件 ：指在发生死锁时，必然存在**由两个或多个进程**构成的环形链，环形链中的每一个进程都在等待下一个进程释放其占用的资源。

:star2:注意区分请求保持和不剥夺，请求保持是对自己已获得资源保持不放，不剥夺是资源只能由自己释放。

:star2:死锁和饥饿的区别：饥饿可以只有一个进程，死锁至少两个进程；饥饿进程处于就绪或阻塞态，但死锁进程一定处于阻塞态。

### 应对死锁的基本方法

:star2:五种应对方法（预防、避免、检测、解除、忽略）由严到宽，并发性有由小到大。死锁预防是最严苛的一种策略，“死锁预防可以确保系统不发生死锁”是正确说法，因为破坏了必要条件，所以可以确保系统不发生死锁。那么如果问的是确保进程正确运行，回答的分配策略就是预防的三种和避免的一种。更大的并发性指的是允许更多的进程无等待的向前推进，五种方法的系统并发性由小到大，忽略死锁能获得最大的系统并发性（不去管，当然并发性最大）

#### （1）预防死锁

通过施加限制条件，破坏死锁的四个必要条件

- 互斥条件：是设备的固有特性决定，不能破坏；
- 请求保持条件：静态分配资源，一次性请求所有需要的资源，只有当所有资源都可用时才分配给进程。缺点：资源浪费严重，进程延迟执行。
- 不剥夺条件：剥夺资源，允许系统抢占部分或全部资源，确保高优先级的进程能够及时获得所需的资源，这可能涉及到挂起低优先级的进程， 以便为高优先级进程腾出资源。缺点：实现代价比较大，可能失效。一般适用于易保存和恢复状态的资源，如CPU。
- 环路等待条件：为资源顺序编码，并按需申请分配，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。在任何一个时刻，总有一个进程拥有的资源编号是最大的，这个进程申请之后的资源必然畅通无阻。因此，不可能出现所有进程都阻塞的死锁。现象缺点：顺序难确定，新设备加入困难，增加程序员负担。

#### （2）避免死锁

在资源的动态分配过程中，用某种方法去**防止系统进入不安全状态**。

:star2:注意，是避免系统进入死锁状态，不能用于判断系统是否处于死锁。

安全状态：系统能按某个进程顺序（安全序列 ）来为每个进程分配所需资源，直至对资源的最大需求，使每个进程都可顺利地完成。

:star2:不安全状态中包含死锁，也就是进入不安全状态不一定会导致死锁，死锁一定处于不安全状态，系统处于安全状态则一定不会出现死锁。

允许进程动态地申请资源，但系统在进行资源分配之前，首先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配给进程，否则进程等待。

##### 银行家算法

<img src=".\assets\image-20241026201033619.png" alt="image-20241026201033619" style="zoom:50%;" />

问法：（1）进程P2提出需求1 2 1 0，可以分配给它吗？

​            （2）当前系统可用资源2 7 3 0，能够找到安全序列吗？

​	    （3）可能给的是max/allocation/need/资源总数，此时用每种资源的总数减去allocation，才能得到当前系统中可利用的资源向量

​	    （4）若两个请求立即得到满足后，（题干中满足这两个请求之后系统可用资源量会出现负数）系统是否处于死锁状态？答案：此刻系统并未立即进入死锁状态，因为这时所有的进程尚未提出新的资源申请，全部进程均未因资源请求没有得到满足而进入阻塞状态。只有当进程提出资源申请并且全部进程都处于阻塞态时，系统才死锁。

（1）（2）两个问法的区别仅仅在于，（1）是把1 2 1 0给P2，这几张表格更新以后再进行银行家算法，（2）是直接开始银行家算法。

算法步骤：从P1开始，依次向下，看当前可用资源是否能够满足需求，如果满足，则把该进程执行结束，把其已分配资源加入到系统可利用资源当中；如果不满足，就跳过，注意，不会走回头路，只会在一轮走完以后再从头开始。

如果所有进程都执行成功了，则找到了安全序列；如果当前资源不能满足剩余的所有进程了，就是不存在安全序列。

:star2:安全序列并不是唯一的，银行家算法这种按序去检查能否执行最后得到一种安全序列的做法适用于大题，而对于选择题，应该是根据选项去尝试是否安全。

:star2:死锁避免方法会限制用户申请资源的顺序这句话是错误的，死锁预防中破坏循环等待条件一般采用顺序资源分配法，是限制了用户 申请资源的顺序。但是死锁避免使用的银行家算法，得到的安全序列并不是唯一的，也不是固定的，它只是一种可能的分配方案，而不是一种必须遵循的规则，更没有给出固定的申请资源顺序。

#### （3）检测死锁 

允许系统在运行过程中发生死锁，但可以及时检测到死锁的发生，并精确地确定与死锁有关的进程和资源。

检测方法：在资源分配图中检测到环路。环路中的进程为发生死锁的进程。

死锁定理是用于检测死锁的方法。（可是什么是死锁定理？）

#### （4）解除死锁 

将进程从死锁状态中解脱出来

- 终止所有死锁进程 
- 逐个终止死锁进程，直至死锁不再存在（应从终止代价最小的进程开始）
- 强迫死锁进程释放资源（以损失最小为依据）

#### （5）无作为

鸵鸟策略。

现在的电脑就是对于死锁无作为，因为上述所有方法都难以实现。

:star2:死锁公式

资源数＞进程个数×（每个进程需要的最大资源数-1）就不会发生死锁。

如果满足这个公式，就一定不会死锁；如果不满足，不是一定死锁，是可能死锁。

也就是是最少资源数=进程个数×（每个进程需要的最大资源数-1）+1。

每个进程需要的最大资源数可以是相同的也可以是不同的，相同则直接用这个公式，不同则挨个减一之后求和。

## UNIX进程

UNIX中进程的两种执行状态：

- 用户态User Mode：执行用户程序，提供用户功能，无权执行特权指令
- 核心态Kernel Mode：执行内核程序， 提供系统功能，权限变高，执行所有特权指令。

任何进程，用户态和核心态都可以在一定时机相互转换。

### UNIX进程的用户栈

程序由三部分组成：

- bss段：未初始化的全局变量和静态变量（static）
- data段：已初始化的全局变量
- text段：代码

除此之外：

堆heap：存放进程运行中被动态分配的内存段

栈stack：函数调用的参数、局部变量

<img src=".\assets\微信图片_20241026202829.jpg" style="zoom:80%;" />

ESP栈指针寄存器：是函数栈帧的顶，不是用户栈的顶。如果push后高于esp则esp跟着上升，如果push后仍低于esp，则esp原地不动。

EBP基址指针寄存器：不是栈底，一总是指在old ebp的位置。“EBP把栈帧串联起来”，汇编代码在每一个函数内部以EBP为基地址，访问参数和局部变量。

<img src=".\assets\image-20241026210606633.png" alt="image-20241026210606633" style="zoom:80%;" />

一个完整的函数栈帧（假设函数名fun）

|      fun的局部变量      |
| :---------------------: |
|     **前一帧的ebp**     |
| **执行fun后的返回地址** |
|    **调用fun的实参**    |

如果某部分缺失则栈帧没有这一部分，比如某个函数不含参，则没有调用函数的实参这一部分。

调用实参是从右往左压栈的，所以下面这个程序的输出是（8,7）。从右到左入栈，先计算i++，此时i的值为7，i++返回7，但i自增为8。
再计算i，此时i已经是8。因此，printf接收到的参数是8和7，输出为8,7。

<img src=".\assets\image.png" style="zoom:50%;" />

<img src=".\assets\微信图片_20241026205545.jpg" style="zoom:80%;" />

示例中作为调用函数的main函数和作为被调用函数的sum函数都是由c语言编写的，通过编译器的处理，添加了一些汇编语句，从而完成了栈帧的建立和销毁操作。但如果是汇编语言程序调用c语言程序，汇编语言程序调用汇编语言程序，c语言程序调用汇编语言程序，会形成不完整的栈帧。硬件直接完成函数调用，会没有栈帧。

### UNIX进程的结构特征

展示的是物理地址空间。

<img src=".\assets\微信图片_20241026210915.jpg" style="zoom:80%;" />

proc和text常驻内存是因为不管进程是否在处理机上，系统都需要查询和修改这两个表中的控制信息。

而PPDA区当进程不在处理机上时，系统不会查询和处理。

#### process类

<img src=".\assets\image-20241026213425646.png" alt="image-20241026213425646" style="zoom:80%;" />

p_pid是进程id号，p_ppid是父进程id号。

p_addr是PPDA区起始地址（如果在进程创建时，内存不足，进程图像的可交换部分会创建到盘交换区上，paddr指向盘交换区），p_size是进程可交换部分（PPDA+数据段+堆栈段）的大小，p_textp指向text表的起始地址。

p_stat中，执行和就绪进程的状态是一样的。p_pri进程优先数值越大，优先级越小。当进程阻塞时，p_wchan=& 某一内存变量，指向的是睡眠原因的地址。

#### p_flag的六种标志位

<img src=".\assets\image-20241027201853418.png" style="zoom:80%;" />

#### text类

<img src=".\assets\image-20241026213752496.png" alt="image-20241026213752496" style="zoom:80%;" />

x_daddr是代码在磁盘存的副本的地址，x_caddr是代码段起始地址，x_size是代码段长度。

当进程下台时，代码段是否随进程可交换部分一起换出内存，取决于x_ccount。如果值大于1，证明除了自身进程，还有其他进程在共享该代码段，所以不能换出。

#### user类

<img src=".\assets\image-20241026214032146.png" alt="image-20241026214032146" style="zoom:80%;" />

u_rsav[2]存的是swtch导致进程下台时保存现场存的核心栈ebp和esp。

u_procp指向proc表起始地址。u_MemoryDescriptor后续会用到，里面有相对虚实地址映射表地址，数据段大小等等信息。

#### processmanager类 

<img src=".\assets\image-20241026214253263.png" alt="image-20241026214253263" style="zoom:80%;" />

RunRun在swtch中会用到，等于0不进行进程切换，不等于0证明目前台上的不是优先级最高的进程，要进程切换。

<img src=".\assets\image-20241026212702423.png" alt="image-20241026212702423" style="zoom:80%;" />

proc表中的p_addr指向PPDA区，PPDA区的u_procp指向proc表，proc表中的P-textp指向text表，text表中的x_caddr指向代码段。

三者是勾连关系。一般是从User对象，沿着u_procp指针找到Process对象，继而根据Process对象的p_textp指针得到Text对象。
<img src=".\assets\image-20241029214753151.png" alt="image-20241029214753151" style="zoom:80%;" />

<img src=".\assets\image-20241029214735007.png" alt="image-20241029214735007" style="zoom:80%;" />

## 中断

中断：接收到**中断请求信号**的处理机将暂停正在执行的程序，转去**处理IO完成事件**的过程称为中断。

:star2:**外设准备数据的时间应该大于中断处理时间**。若外设准备数据的时间小于中断处理时间，则可能导致数据丢失，以 输入设备为例，设备为进程准备的数据会先写入设备控制器的缓冲区 (缓冲区大小有限)，缓冲区每写满一次，就向CPU发出一次中断请求，CPU 响应并处理中断的过程，就是将缓冲区中的数据“取走”的过程，因此若外设准备数据的时间小于中断处理时间，则可能导致外设往缓冲区写入数据的速度快于CPU 从缓冲区取走数据的速度，从而导致缓冲区的数据被覆盖，进而导致数据丢失。

:star2:PA有外设请求，睡眠，外设结束时此时在台上的是PB，所谓“中断”是让PB中断现在做的事情，去处理核心态下的工作。

### 请求处理信号

<img src=".\assets\微信图片_20241026220000.jpg" style="zoom:80%;" />

### 中断处理流程

<img src=".\assets\image-20241026221736893.png" alt="image-20241026221736893" style="zoom:80%;" />

#### 中断隐指令

硬件完成。

1. 关中断
2. 核心寄存器压栈（顺序：SS/ESP/EFLAGS/CS/EIP）
3. 代码段、堆栈段转核心态（指的是SS和CS的更新，最后两位11变00）
4. 查找并装入中断向量（门）（CS+EIP更新）
5. 程序跳转（CS+EIP更新完，就完成了程序跳转，来到了中断入口程序地址）

##### 关中断

原因：保护现场的工作非常重要，不允许被打断。

具体：x86硬件只管关中断，不管开中断，所以内核程序员要负责。如果允许中断嵌套，就要在确保保护现场完成就打开IF；如果不允许中断嵌套，就在中断结束再开IF。即使不设置IF也没关系，因为在恢复现场时EFLAGS弹出，IF就变回来了。（因为在进入本次中断时IF一定是开的）

##### 实施硬件现场保护

补充知识：实模式与保护模式

过去是20位地址，现在是32位地址。

<img src=".\assets\微信图片_20241026231313.jpg" style="zoom:80%;" />

段寄存器最后2位00核心态，11用户态。

注意以下五个寄存器的名字。

<img src=".\assets\image-20241026232356757.png" alt="image-20241026232356757" style="zoom:80%;" />

###### CS + EIP

CS + EIP：断点的位置，CS + EIP叫做中断向量，不同的中断源有不同的中断向量（硬件规定好的），中断隐指令中，现场保存结束后，会装入中断入口程序所需的CS和EIP，以实现跳转到中断入口程序。那么在修改之后，CS的最后两位就从11变00了，转为了核心态。

如何找到中断源的CS+EIP

<img src=".\assets\微信图片_20241026232009.jpg" style="zoom:80%;" />

###### SS+ESP

中断隐指令中，现场保存结束后，会将SS设置为核心栈段选择子。如果先前在用户态，SS+ESP先压栈，再修改（修改的值就是核心栈的栈底，因为之前在用户态，核心栈一定是空的，那么此时要进入核心栈，就是从核心栈的栈底开始的，核心栈栈底就是PPDA区的底，是3G+4M-1）；如果先前在核心态，不用压栈，不用修改，直接存其他寄存器的值（因为压栈的目的就是恢复时返回，那么之前就在核心栈，返回时就在原地，所以不用存）。

那么在SS修改的过程中，最后两位就从11变00了，转为了核心态。

<img src=".\assets\image-20241026232447131.png" alt="image-20241026232447131" style="zoom:80%;" />

#### 中断入口程序

中断入口程序所有中断源基本一样，但转去执行的中断处理程序，不同中断源不同。

注意，中断入口程序是c语言程序，“内联''汇编指令是define，不是函数调用。

<img src=".\assets\image-20241027104134901.png" alt="image-20241027104134901" style="zoom:80%;" />

①保存中断现场：SaveContext（内联汇编）通过一组汇编指令，将CPU中其他的寄存器值压栈，并压入两个分别指向软件现场和硬件现场的指针（注意：两个指针是在软件保护现场这一步压入的）

②完全进入核心态：SwitchToKernel  （内联汇编）通过一组汇编指令，将CPU中用于寻址的段寄存器全部改为核心态（在中断隐指令中，SS和CS已经11变00，现在还剩DS和ES，在进入中断处理程序之前，必须用指令对DS和ES赋值，所有段描述符转向核心态。

③调用中断处理程序：CallHandler （内联汇编）通过一组汇编指令，实现指令跳转，转向不同中断处理程序（这里是汇编程序调用了C程序）。在中断处理程序中，绝大多数会去唤醒因这次IO操作而睡眠的进程。

④通知中断控制器，中断处理结束

⑤例行调度：后续详讲

⑥恢复现场： RestoreContext() 把软件现场的栈帧都弹出，从核心栈中将保存             			的值装回CPU内的寄存器

​    手工销毁栈帧：Leave()把中断入口程序栈帧弹出

​    退出中断：InterruptReturn()中的iret，弹出中断隐指令的五个寄存器，装回		       的CS和EIP让进程回到中断前的状态和位置。

:star2:退出中断的iret是中断隐指令的逆操作，中断隐指令是硬件做的，但其逆操作是软件完成的。

##### 例行调度

:star2:判断中断前的状态是利用存的两个分别指向硬件现场和软件现场的指针，context->xcs& 0x3，如果0则00，先前核心态；如果1则11，先前用户态

如果中断前是用户态，RunRun=0则恢复中断现场，RunRun≠0则swtch切换其他进程上台。

如果中断前是核心态，直接恢复中断现场，被中断的核心态进程不会放弃处理机内核，被interrupt的任务很重要，必须继续执行完，体现了 **<font color=red>内核不可抢占</font>**。

如果进程在此处下台，保存现场存的是当前核心栈的esp和ebp，存入下台进程User结构中的u_rsav[2]数组。新上台的进程User结构中的u_rsav[2]数组中的值装入esp和ebp，就指向了新进程的核心栈，返回中断入口程序，正常中断返回。（后续会讲，不仅仅是esp和ebp，因为它们两个都是逻辑地址，还需要切换页表来更新物理地址）

所有中断返回前下台的进程，只有再次被选中上台，才会从Swtch回到中断入口程序继续执行。

（后续应该还会讲进程切换，我目前的理解是进程如果在此处下台，就会被放入队列，每次RunRun的时候都在这个队列里面选最优）

##### 核心栈的变化

<img src=".\assets\image-20241027111202205.png" alt="image-20241027111202205" style="zoom:80%;" />

中断隐指令，硬件现场保护，ss/esp/eflags/cs/eip入栈。

中断隐指令是硬件完成，中断入口程序是c语言程序，所以是硬件调用c语言程序，没有调用实参和返回地址，只有old ebp和局部变量，又由于中断隐指令是硬件完成在执行的过程中没有动过ebp和esp，所以硬件现场存的esp指向用户栈栈顶，中断入口程序栈帧的old ebp也是指向用户栈。就像下图所示。

<img src=".\assets\image-20241027120433230.png" alt="image-20241027120433230" style="zoom:80%;" />

软件保护现场，其余寄存器入栈。

中断入口程序中的内联汇编调用中断处理程序，所以是汇编程序调用c语言程序，没有调用实参。在软件现场保护时没有动过ebp，所以中断处理程序的栈帧里old ebp指向的是中断入口程序的ebp位置。缺少调用实参这一部分，但是在中断处理程序中又需要使用之前保存的寄存器的值，所以引入了两个指针（但注意，这两个指针是在软件现场保护时压栈的，不是在调用中断处理程序时入的栈,但是大括号括起来时两个指针是括进中断处理程序栈帧，不是括进软件现场）在中断处理程序中使用现场保护的寄存器中的数据，就是regs->eax，context->xcs& 0x3这样用。

<img src=".\assets\image-20241027113602465.png" alt="image-20241027113602465" style="zoom:80%;" />

:star2:如果不用两个指针，采用传参？就是中断处理程序变成void Handler( int gs, int fs, int ds, …, int eflags, int esp, int ss);

问题在于参数表太长，且软件现场不能发生变化，而且，中断入口程序栈帧的局部变量大小是未知的，而如果传参是以EBP为基准，那么因为局部变量数量未知，硬件现场是没法确定是EBP加几的，所以根本无法传参。

在执行中断处理程序时，先压入了中断处理程序的栈帧，如果调用其他函数，继续压入。

<img src=".\assets\image-20241027114657827.png" alt="image-20241027114657827" style="zoom:80%;" />

中断处理程序结束后，返回中断入口程序，中断处理程序栈帧撤销（注意，两个指针不撤销，因为两个指针是软件现场保护阶段压入的，它们只是和中断处理程序栈帧一起看作了一个完整的栈帧，但并不属于中断处理程序栈帧）

<img src="assets/image-20241027114834573.png" alt="image-20241027114834573" style="zoom:80%;" />

进入到例行调度，如果RunRun≠0，会调用swtch函数，c语言调用c语言，swtch不含参，缺少调用实参部分。swtch栈帧的old ebp指向的是中断入口程序的ebp位置，因为中断处理程序的old ebp指向的是中断入口程序，而中断处理程序栈帧撤销后old ebp被弹出，就回到了中断入口程序的ebp。swtch栈帧的返回地址指向的是CLI关中断的地址，因为swtch栈帧执行结束，要去往的地方就是cli关中断，等待下一次调度。

:star2:对于所有在中断返回前下台的进程，核心栈都长得一模一样，就是下图。因为中断返回前下台的前提是中断前处于用户态，那么进入核心栈时就是空的。而对于每个中断会不同的中断处理程序这时已经撤销，所以核心栈一模一样，都是下图。

<img src=".\assets\image-20241027114935413.png" alt="image-20241027114935413" style="zoom:80%;" />

如果不调度或者调度返回，则核心栈帧依次撤销，恢复现场撤销两个指针+软件现场寄存器，手动销毁栈帧撤销中断入口程序栈帧，退出中断撤销硬件现场寄存器。（下图的三个颜色和栈帧颜色依次对应）

<img src=".\assets\image-20241027115443148.png" alt="image-20241027115443148" style="zoom:50%;" />

### 中断的作用

1. 保证了CPU和设备之间的并行操作

2. 提供了进程执行内核代码的机会
3. 3.多道程序并发的硬件基础

:star2:在例行调度的RunRun检查时，是**UNIX中唯一的抢占时机**。（此外，在有些系统中，当有更紧急的任务，如更高优先级的进程进入就绪队列或者当前进程的时间片用完时，也被强行剥夺CPU，那么更高优先级进程进入就绪队列和时间片轮转同样满足这句话，例行调度是唯一的抢占时机。我之前以为更高优先级进程是来了就会抢占上台，那么中断怎么做到，现在知道了是进程的优先级并不是在进入就绪队列的时候就被设置成最高优先级的，正像优先权调度算法讲到的一般选择调度、时钟中断、陷入等时机调整动态优先级，所以优先级的转换就是在中断中发生的，而时间片的轮转就是依靠的时钟中断。因此，抢占都发生在中断，都在例行调度，这句话，没有问题。）

:star2:**进程在用户态和核心态之间转换的开关，就是中断。**现代操作系统中断扩展后，**开关就是中断、异常、系统调用。**

<img src=".\assets\微信图片_20241027120217.jpg" style="zoom:80%;" />



## 互斥与同步（进程通信）

任何一个进程都不能保证**一条高级语言代码**能够全程在CPU上执行而不被打断。（因为一条高级语言会对应着多条汇编语言）

**临界资源**：同时只允许一个进程使用的软件和硬件资源。

**临界区**：访问临界资源的**程序段**。 （必须是访问临界资源的代码，其他说法都不对，比如，临界区是进程中用于实现进程互斥的代码这种说法就是错误的）

**相关临界区**：访问同一临界资源的临界区。（出现在不同的进程中，进程之间用同一个临界资源）

竞争条件：多个进程同时读写共享的数据，而最终的结果取决于进程执行的时序。包含竞争条件的程序是错误的（与时序相关的错误）。

:star2:处于临界区的进程也可能因中断或抢占而导致调度。如果进程在临界区内请求的是一个需要等待的资源，比如打印机，则它主动放弃CPU，让其他进程运行。但不允许新上台的进程进入该临界区。

### 互斥

**互斥**：同时使用同一临界资源的进程应当互斥，保证在任何时刻，最多只有一个进程运行在临界区。

#### 互斥机制应遵循的规则

(1)**空闲让进**。当无进程处于临界区时,表明临界区处于空闲状态,应允许一个请求进入临界区的进程立即进入自己的临界区,以有效地利用临界资源。（门必须是进程来关，内核没有权利锁门）
(2)**忙则等待**。当已有进程进入临界区时,表明临界资源正被访问,因而其他试图进入临界区的进程必须等待,以保证对临界资源的互斥访问。
(3)**有限等待**。对要求访问临界资源的进程,应保证在有限的时间内能进入自己的临界区,以免陷入“死等”状态。（避免饥饿）
(4)**让权等待**。当进程不能进入自己的临界区时,应立即释放处理机,以免进程陷入“忙等”状态。（避免死锁）

#### 实现互斥的方法

##### （1）硬件实现开关中断

在单处理机系统中，借用中央处理机中的硬件中断开关位作为临界区的锁。

其优点是简单、可靠，但是它也有一定的局限性和若干不足之处，主要表现在以下四个方面：
①它不能用于多处理机系统。原因在于多个处理机都有其各自的中断开关,**一个处理机关中断并不能阻止在其他处理机上运行的进程进入相关临界区**。
②如果临界区中包含有使执行它的进程可能进入阻塞状态的因素,则不能使用这种方法。如果关了中断，台上进程又要IO，就会造成无人可以处理的场面，导致停机。（所有需要内核处理的问题都无法得到解决）
③如果临界区比较长,则本方法会降低中断响应速度。
④这里是**用一把锁处理各类临界区**,**不必要地扩大了互斥范围**。（对比后面的信号量方法，是对于一个临界资源，设置一个信号量；硬件方法只是在系统中设置一把锁，不区分临界资源）

所以该方法只适用于操作系统内核的进程互斥。

例如：<img src=".\assets\image-20241015174140309.png" alt="image-20241015174140309" style="zoom:40%;" />

##### （2）锁变量

为每个临界资源设置一个锁变量lock，lock=0表示锁开着； lock=1表示锁关闭 （初始为0）。

锁变量的检查和置1应同时完成，如果中间出现空隔，会出现“一把锁被数次关闭，几个进程同时进入临界区”的情况。→用中断来做

<img src=".\assets\image-20241015174221706.png" alt="image-20241015174221706" style="zoom:33%;" />

利用开关中断来保证关锁操作的完整性，并不是实施关锁操作本身。<font color=red>中断不是服务于临界区而是服务于lock变量。</font>

弊端：在上述方法中,如果发现锁原先已处于关闭状态则进入检测循环,而究竟要循环多少次是不可预测的,这就浪费了宝贵的处理机时间。为了避免这种弊病,可对关锁操作略作改进。其主要思想是:如果某一进程进行锁测试操作时,发现它已经关闭,则进入封锁状态并记录封锁原因；将锁关闭的进程在执行完临界区程序后,除了将锁打开,还要检查有无进程等待进入同类临界区,若有这样的进程,则将它们转为就绪状态。<font color=red>（就是让它转为阻塞状态而非就绪状态，并且把阻塞原因记录为等待这个锁，后续锁打开了就会有进程来唤醒它）</font>

##### （3）信号量

<img src=".\assets\image-20241015174640946.png" alt="image-20241015174640946" style="zoom:50%;" />

**初始化的值=可用资源数**

<img src=".\assets\image-20241015174747761.png" alt="image-20241015174747761" style="zoom:40%;" /> <img src=".\assets\image-20241015174814491.png" alt="image-20241015174814491" style="zoom:40%;" />

value ≥ 0时，value = 当前可用资源数

value＜0时，|value|= 资源缺少数量/排队进程数量

P和V必须成对出现。利用开关中断使它们保持**原子性**（内核原语）

<img src=".\assets\image-20241015175209420.png" alt="image-20241015175209420" style="zoom:45%;" />

假设进程 pa 先执行p(mutex)操作,它将 mutex.value 的值减为 0。然后 pa 执行临界区程序。若此时进程pb开始执行p(mutex)操作,则将mutex.value 的值减为-1。于是,**进程pb转变为封锁状态,并进入信号量mutex的等待队列**。当进程pa退出临界区,执行v(mutex)时,mutex.value的值增为0。于是**从信号量mutex队列中释放进程 pb,将其恢复为就绪状态,当进程pb再次被调度占用处理机时,就立即执行临界区**。（pb去阻塞，然后被唤醒，并不是一旦唤醒就可以继续执行，而是转为就绪状态，要等待调度上台才能继续执行）

:star2:对于两个并发进程，设互斥信号量mutex初值为1。若mutex=0，表示有一个进程进入临界区；若mutex=-1，表示有一个进程进入临界区，另一个进程等待进入。

### 同步

同步：协同工作的几个进程需要在某些确定的点上协调他们的工作。

<img src=".\assets\image-20241015180056889.png" alt="image-20241015180056889" style="zoom:50%;" />

假设进程 pa **先到达**（先于pb到达） L1点,当它执行p(proceed)时,将 proceed.value 的值减为-1。**于是pa进人封锁状态并进入信号量proceed等待队列**。然后进程pb到达L2点。当它执行v(proceed)时,将proceed.value的值增为0。**于是释放pa并将其转为就绪状态，pa就可在下次被调度到时,在L1点后继续执行下去**。由此可见,**当进程pa到达L1点时,除非进程pb已经过了L2点,否则进程pa就要暂停等待**。也就是说,**进程pa在L1点必须与进程pb同步**。在这种同步操作中,进程pa受到进程pb的制约,而进程pb却不受进程 pa的制约（不是互相等，是A要等到B来了才能往下走，B没有限制）。

:star2:上面讨论的信号量由于交换的信息量少而被归结为进程的**低级通信**。进程之间的信息交换，有可能多至成千上万个字节，这时称为进程的**高级通信**。高级通信进行**消息传递**，是一种**间接通信方式**，有**发送**和**接收**两条基本原语。

### 经典进程通信问题

题目设置：

- 有哪些同步和互斥关系
- 针对同步和互斥关系，设置信号量并规定初值
- 补全代码中的PV操作

#### 生产者消费者问题

<img src=".\assets\image-20241015181057792.png" alt="image-20241015181057792" style="zoom:50%;" />

<img src=".\assets\image-20241015192633184.png" alt="image-20241015192633184" style="zoom:60%;" />

互斥关系：对缓冲区的访问要互斥进行

同步关系：缓冲区要有产品消费者才能取，缓冲区要有空余位置生产者才能放

信号量：

mutex=1，缓冲区互斥信号量

empty=缓冲存储区的剩余空位数量

full=缓冲区存放产品的数量

:star2:如何记忆empty和full，P的操作是看信号量是否大于0，大于0才可执行。生产者是要缓冲区空余位置大于0才能放，所以empty是空余位置；消费者是要缓冲区的产品数量大于0才能拿，所以full是缓冲区的产品数量。

p(empty)和p(mutex)不能调换：如果调换，producer的p(mutex)过了，但p(empty)没过，要等consumer的v(empty)但consumer根本进不去p(mutex)，造成了循环等待的进程死锁。

v(empty)和v(mutex)是可以调换的。

:star2:**怎么理解互斥实质上是同步的一种特殊情况**

<img src=".\assets\image-20241015193153178.png" alt="image-20241015193153178" style="zoom:67%;" />

我认为直接和间接的界定在于，同步是表面上看起来就是A要等待B的到来，互斥则是表面上看起来是A自己在PV，实际上也是A要等待B结束，才能进入。

:star2:**缓冲区的存放方式**

k和t分别是生产者和消费者的数组下标。

生产者和消费者都是从缓冲区[0]开始的，二者的数组下标是独立的。

所以拿出和放入都是数组下标从0开始一直往后走。

比如：

缓冲区[0]放入，缓冲区[1]放入，之后来了一个消费者，它拿出的是缓冲区[0]，下一位是生产者，它会放入缓冲区[2]，而不是缓冲区[0]，生产者不会管之前的哪个物品被拿走了，它只会一直往下走，等到走到最后一个之后，通过(k+1) mod n来回到0开启下一轮放入。

是否可以拿出和放入不是靠k和t约束的，不是k到了n就代表放满，t到了n就代表取完，而是用empty和full来判断的，通过empty和full的约束，就不会出现在第一轮循环时（k和t都还没第一次到达n时）出现t>k的情况

比如：

生产者放了一个，k=1；消费者先取一个，t=1；这时消费者还想取，但被full约束住了，取不了，所以不会出现k=1而t=2的情况。

在第一轮循环时，生产者是按数组下标挨个放进去的，消费者是按数组下标挨个抽出来的，在full和empty的约束下，一定不会跑到生产者还没放到的位置去抽。而在进入到大于一的循环轮次之后，**<font color=orange>可以把缓冲区理解成一个圈，在empty和full的约束下，消费者的步调不会快于生产者，生产者的步调不会快于消费者一圈，它们都是在自己走过的每一步拿出和放入，不能走过一个位置却不拿不放。</font>**

**<font color=red>可以总结为：环绕缓冲区</font>**



:star2:**缓冲区为共享存储区，生产者和消费者不能同时访问**

相关临界区不一定都是同一个变量，之前记录在馆人数的例子是同一个变量count，但在生产者消费者问题中，k和t是两个变量，但它们都是对于同一个缓冲区的拿和放，所以是互斥关系。几个变量取决于记录方式，不是相关临界区的评判标准。是否为相关临界区的标准是不同主体能否同时访问。



:star2:**对生产者和消费者的数量有没有约束？**

没有约束，mutex不仅约束了生产者和消费者的互斥，也约束了生产者之间、消费者之间的互斥，即：mutex约束了所有有访问缓冲区需求的人员，保证任意时刻只能有一个人员访问缓冲区。

如果变成多个生产者或者消费者，mutex的值依旧为1，不会随着生产者消费者数量而改变。因为任一时刻只能有一个进程访问缓冲区。



##### 延伸例题

###### 信箱辩论

<font color=orange>仍然是单生产者-单消费者，只是缓冲区从一个变成了两个。</font>

<img src=".\assets\微信图片_20241015193845.jpg" style="zoom:50%;" />

实际上就是两套生产者消费者，红框黄框各是一套。对于A的信箱： A是消费者，B是生产者；对于B的信箱： B是消费者，A是生产者。

注意：“回答问题并提出一个新问题”这个操作是不涉及任何PV的，是自己做的事情，与别人在干什么无关，就不涉及同步和互斥。



###### 吃水果问题

<font color=orange>两个生产者，两个消费者。</font>

桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。

互斥关系：对盘子的访问要互斥进行（盘子就是缓冲区）

同步关系：

- 爸爸放了苹果女儿才能拿苹果；
- 妈妈放了橘子儿子才能拿；
- 只有盘子为空时，爸爸或者妈妈才能放水果。

:star2:注意：不是四对同步关系（只有女儿拿了苹果爸爸才能放苹果、只有儿子拿了橘子妈妈才能放橘子），而是三对同步关系。爸爸妈妈只需要看盘子是不是空的，不用去在乎苹果还是橘子被拿走了没有。

信号量：

mutex=1盘子的互斥信号量

apple=0盘子中的苹果个数

orange=0盘子中的橘子个数

plate=1盘子中的剩余可放水果位置

<img src=".\assets\image-20241027141737560.png" alt="image-20241027141737560" style="zoom:80%;" />

<font color=red>可不可以不用互斥信号量？</font>

<img src=".\assets\image-20241027141815340.png" alt="image-20241027141815340" style="zoom:80%;" />

即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象

原因在于：本题中的缓冲区大小为1，**在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是1**。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。

<font color=red>如果盘子（缓冲区）容量为2？</font>

父亲 P(plate)，可以访问盘子→母亲 P(plate)，可以访问盘子→父亲在往盘子里放苹果，同时母亲也可以往盘子里放橘子。于是就出现了两个进程同时访问缓冲区的情况，**有可能导致两个进程写入缓冲区的数据相互覆盖的情况**。
**因此，如果缓冲区大小大于1，就必须专门设置一个互斥信号量 mutex 来保证互斥访问缓冲区。**

:star2:在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。

###### 和尚打水问题

<font color=orange>多生产者，多消费者。</font>

某寺庙，有小和尚和老和尚若干，有一个水缸，由小和尚提水入缸供老和尚饮用。水缸可以容纳10桶水，水取自同一口井中，由于水井口窄，每次只能容纳一个水桶取水。水桶总数为3个。每次入水、取水仅为一桶，且不可同时进行。

信号量：

v1=1 小和尚从井里提水 

v2=1 老和尚从缸里取水，小和尚往缸里倒水 

amount=3 水桶数量 

full=0 水缸里有几桶水 

empty=10 水缸里还能放几桶水

```
小和尚（）{
		p(empty)
		p(amount)
		p(v1)
		从水井打水
		v(v1)
		p(v2)
		往缸里倒水
		v(v2)
		v(amount)
		v(full)
	}
	
	老和尚（）{
		p(full)
		p(amount)
		p(v2)
		从缸中取水
		v(v2)
		v(amount)
		v(empty)
	}
```

###### 吸烟者问题

<font color=orange>可生产多种产品的单生产者以及多消费者问题。</font>

假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）。

生产者可生产的产品一共有三种：组合一：纸+胶水；组合二：烟草+胶水；组合三：烟草+纸。

互斥关系：桌子可以看作是一个容量为1的缓冲区，其访问是互斥的；

同步关系：

- 桌上有组合一之后第一个抽烟者取走组合一；
- 桌上有组合二之后第二个抽烟者取走组合二；
- 桌上有组合三之后第三个抽烟者取走组合三；
- 取走东西使用完成后供应者将下一个组合放到桌子上。

<img src=".\assets\15bdf21e0f0125093d5317356631df65.png" style="zoom:80%;" />

“轮流让各个吸烟者吸烟”必然需要“轮流的在桌上放上组合一、二、三”， 注意是如何用一个整型变量 i 实现这个“轮流”过程的。如果题目改为“每次随机地让一个吸烟者吸烟”，把i=(i+1)%3改成i从0~2中random取值。

#### 嗜睡理发师问题

<font color=orange>本质上也是单生产者多消费者问题。只是多了顾客达到上限会离开，顾客达到下限理发师会睡觉。</font>

<img src=".\assets\image-20241015194358609.png" alt="image-20241015194358609" style="zoom:50%;" />

<img src=".\assets\image-20241015195448199.png" alt="image-20241015195448199" style="zoom:60%;" />

waiting是当前理发店内顾客数。（是本题的缓冲区）

理发师在没有顾客时会睡觉，要等待第一个顾客唤醒，所以P(customer)在开始。

顾客坐下的前提是有空座位，但开始理发的前提是理发师空闲，所以理发师要在每次开始理发前发出V信号告知顾客。



:star2:**理发师进程是while，顾客进程是if**

因为理发师要持续工作，而顾客haircut结束后就离开了。

顾客if(waiting<CHAIRS)，那么如果顾客来到理发店的时刻没有空椅子，就不会进入if，进程直接结束。顾客不会在理发店里站在等待空座位，会直接离开。**customer在waiting达到阈值时不是去sleep而是直接end**。



:star2:**各个p,v操作的位置能否互换？**

barber和customer的V(mutex)和V(barbers)可以互换位置，其他的PV位置不能动。



:star2:**现在的代码是可以适用于一个理发师多个顾客的，那么要是多个理发师呢？**

顾客已经适用于多位是因为在customer中，if的判断就要用到waiting，所以P(mutex)出现在了if之前也就是第一句，正好顺便充当了多位顾客互斥的功能。

现在的代码如果变成多位理发师也是适用的，每位理发师都发出p(customer)的请求，每当来一位顾客，就唤醒一位理发师，每当一位理发师可以开始理发，就会喊来一位等待的顾客。



#### 读者-写者问题

<img src=".\assets\image-20241015200446034.png" alt="image-20241015200446034" style="zoom:80%;" />

互斥关系：写进程需要和任何进程都互斥访问磁盘。

同步关系：有吗？

:star2:**如何满足“对同一个磁盘文件的并发读写访问”**

写进程之间需要互斥。多个读进程可以同时访问，写进程需要与所有的读进程互斥访问。

即读进程会放同类进程进来，写进程不会放任何进程进来。

“写进程不会放任何进程进来”，包括两点，第一点是与其他写进程互斥，所以在writer进程设置wmutex；第二点是与所有读进程互斥，所以reader进程中也会出现对wmutex的设置。

而在

##### 读者优先

<img src=".\assets\微信图片_20241015203117.jpg" style="zoom:40%;" />

readcount是读者的个数，第一个进入的读进程通过P操作封锁写进程，最后一个离开的读进程通过V操作释放写进程。

如果第一个来的进程是写者，如果在写进程执行到V(wmutex)之前，（这中间可以来无数个写者），来了一个读者，会停留在P(wmutex)，等到（所有在读者来之前来的写者）写进程执行完V(wmutex)，读者进程可以继续执行，会把写进程封锁，直到所有的读进程离开。

所谓的读者优先，是一旦第一个读者开始执行进程，就会把所有的读者执行完，再去执行写者，如果有源源不断的读者到来，那么写者会饿死。而不是第一个读者到来时，就会立马开始执行，只是会在把所有比第一个读者来得早的写者都执行完后，才会开始执行第一个读者。

##### 写者优先

<img src=".\assets\image-20241015203158128.png" alt="image-20241015203158128" style="zoom:50%;" />

如果第一个进程先来的是写者，会把读进程封锁，直到所有的写进程离开。

如果第一个进程先来的是读者，会把wmutex变成-1，如果在读进程执行到V(rmutex)之前，（这中间可以来无数个读者），来了一个写者，会停留在P(rmutex)，等到（所有在写者来之前来的读者）读进程执行完V(rmutex)，写者进程可以继续执行，（因为在信号量rmutex的阻塞队列上，是FIFO，每次的V操作唤醒的都是阻塞队列的队首）会把读进程封锁，直到所有的写进程离开。

所以所谓的写者优先，就是写者不会晚于它到来的顺序开始执行；而它一旦开始执行，就会把所有后续到达的写者都执行完再回到读者的执行去。

:star2:所以，上述的所谓读者优先、写者优先，都是相对的，只是不会晚于它到来的顺序开始执行，它一旦开始执行，就会把所有后续到达的同类进程都执行完再回到另一类的执行去。这是信号量的阻塞队列的FIFO特性决定的。

##### 读写平等

在网络上找到的答案：

```
int readcount=0; 
semaphore mutex=1, rw=1 w=1; 
 
读者进程：
        P(w);
        P(mutex);
        if (readcount == 0)
	       P(rw);
    	readcount++;	
    	V(mutex);
        V(w);
		READUNIT();
    	P(mutex);
    	readcount--;
    	if (readcount == 0)
    		V(rw);
    	V(mutex);
 
 
写者进程：     
    P(w);
    P(rw);
	WRITEUNIT();
    V(rw);
    V(w);
```

相对于读者优先的代码，只是多了一个w信号量，这一个信号量带来了什么呢？

假设到来队列是R1,R2,W1,R3

如果是之前的读者优先，执行顺序会是R1,R2,R3,W1，如果在R3执行结束之前还有源源不断的R到来，那W1会被饿死。

而现在的代码，执行顺序会是R1,R2,W1,R3，即按照到来顺序执行。具体：因为w的FIFO阻塞队列，所以W1一定会在R3之前进来，W1可能会被卡在rw，所以需要等待最后一个读进程R2离开把RW封锁解除后W1才能执行。W1执行结束w封锁解除R3才能进入。

现在的代码，不管进入读进程还是进入写进程，都受到w互斥信号量的约束，即排成一个w信号量的FIFO阻塞队列。因为这个信号量在代码的最前面，所以一切进程都会停留在该阻塞队列中，从而保证了执行的顺序是按照进程到来的顺序，而不会写进程一直来导致读进程饿死，或者读进程一直来导致写进程饿死。

#### 黑白棋问题

两个人下棋，一方执黑棋，一方执白棋。要求双方轮流下子。给出两种情况的解决办法：

（1）执黑子一方先下

<img src=".\assets\image-20241027164348488.png" alt="image-20241027164348488" style="zoom:67%;" />

（2）双方都可先下，谁先抢到棋盘谁先下。然后轮流。

<img src=".\assets\image-20241027164427252.png" alt="image-20241027164427252" style="zoom:67%;" />

:star2:**信号量初值总量问题**

黑白棋与其他问题的一个显著不同之处在于：资源总量始终只有1。

资源总量就是当前可以放下棋子的永远只能有且仅有一人。

比如：

当用两个信号量black和white，规定黑子方先下时，则初值black=1,white=0。

上课时老师说如果改成双方都可以先下，把black和white初值都置1就行了，其实是不对的，因为此时资源总数变成了2。黑方先走，black变0，走完white变2，那么此时白方可以连走两次。

如果要改成双方都可以先下，只能是课件上给出的，用一个turn来约束，信号量变成一个，双方都是m，m的初值是1。



#### 哲学家进餐问题

一张圆桌旁围坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。当哲学家饥饿的时候，只有同时拿到了两根筷子才可以开始进餐。如果筷子已在他人手上，则需等待。

一共有五个哲学家，也就是五个进程；五只筷子，也就是五个临界资源；因为哲学家想要进餐，必须要同时获得左边和右边的筷子，这就是要同时进入两个临界区（使用临界资源），才可以进餐。

信号量：

定义互斥信号量数组 mutex[5]={1,1,1,1,1} 用于实现对 5 个筷子的互斥访问。

并对哲学家按 0~4 编号， 哲学家 i 左边的筷子编号为 i ，右边的筷子编号为 ( i +1)%5 

<img src=".\assets\image-20241027142429877.png" alt="image-20241027142429877" style="zoom:50%;" />

每位哲学家都取得右边 一只筷子，并且不肯放弃左边的筷子。这种僵持的状态将不会被打破， 直至所有哲学家饿死。导致死锁。

为了解决五个哲学家争用的资源的问题，我们可以采用以下几种解决方法：

① 至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用餐完毕后能释放他占用的筷子，从而使别的哲学家能够进餐；
② 仅当哲学家的左、右两支筷子可用时，才允许他拿起筷子；
③ 规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。

##### 方法一：控制就餐哲学家数量

破坏循环等待条件。

环路等待条件 ：指在发生死锁时，必然存在**由两个或多个进程**构成的环形链，环形链中的每一个进程都在等待下一个进程释放其占用的资源。

```
semaphore mutex[5] = {1,1,1,1,1};   //初始化筷子信号量
semaphore count = 4;	            //允许就餐的哲学家数量
 
void philosopher(int i){
  do { 
    think()		       //思考
    p(count);		   //占用一个就餐名额
    P(mutex[i]);	   //试图拿左侧叉子
    P(mutex[(i+1)%5]); //试图拿右侧叉子
    eat()			   //进餐
    V(mutex[i]);       //放下左侧叉子
    V(mutex[(i+1)%5]); //放下右侧叉子
    V(count);          //释放一个就餐名额
  }while(true);
}

```

##### 方法二：同时拿起左右的叉子

破坏请求与保持条件。

请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其他进程占用，此时请求进程阻塞，**但又对自己已获得的其他资源保持不放**。 

解决方法：静态分配资源，一次性请求所有需要的资源，只有当所有资源都可用时才分配给进程。缺点：资源浪费严重，进程延迟执行。

```
semaphore chopstick[5]={1,1,1,1,1}; 
semaphore mutex = 1 ;            // 互斥地取筷子 
Pi ( ) {                         //i 号哲学家的进程 
    while(1) 
    { 
        think()		                  //思考
        P(mutex) ; 
        P(chopstick[i] ) ;            // 拿左 
        P(chopstick[(i+1) %5] ) ;     // 拿右 
        V(mutex) ; 
        eat()			              //进餐
        V(chopstick[i] ) ;            // 放左 
        V(chopstick[(i+1) %5] ) ;     // 放右 
    } 
}
```

实际上，这种方法并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子。更准确的说法应该是 ： 各哲学家拿筷子这件事必须互斥的执行 。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞， 也不会有别的哲学家会继续尝试拿筷子。 这样的话 ，当前正在吃饭的哲学家放下筷子后，被 阻塞的哲学家就可以获得等待的筷子了。

##### 方法三：奇偶数哲学家 

破坏循环等待条件。

环路等待条件 ：指在发生死锁时，必然存在**由两个或多个进程**构成的环形链，环形链中的每一个进程都在等待下一个进程释放其占用的资源。

:star2:该题是根据奇偶去直接约束哲学家先左后右还是先右后左，题目也可以是“哲学家中同时存在左撇子和右撇子，左撇子会先拿左，右撇子会先拿右，则破坏了循环等待条件，不会发生死锁。

```
semaphore mutex[5] = {1,1,1,1,1}; 		//初始化信号量
 
void philosopher(int i){
  do {
    think()	
    if(i%2 == 1){         //奇数哲学家先左后右
      P(mutex[i]);
      P(mutex[(i+1)%5]);
    }else{                //偶数哲学家先右后左
      P(mutex[(i+1)%5]);
      P(mutex[i]);
    }
    //eat()
    V(mutex[i]);
    V(mutex[(i+1)%5]);/
  }while(true);
}
```

用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭， 那么只会有其中一个可以拿起第一只筷子， 另一个会直接阻塞。 这就避免了占有一支后再等待另一只的情况。

:star2:哲学家进餐问题的思想和贪心算法截然相反，贪心算法强调争取眼前最好的，而不考虑后续会有什么后果。若哲学家进餐问题用贪心算法来解决，即只要眼前有筷子能拿起就拿起的话，就会出现死锁。然而，若不仅考虑眼前的一步，而且考虑下一步，即要考虑能不能一次拿起两根筷子才做决定的话，就会避免死锁，这就是哲学家进餐问题的思维精髓。



## 习题课

（1）

<img src=".\assets\image-20241015212557977.png" alt="image-20241015212557977" style="zoom:80%;" />

<font color=orange>2、3都是让就绪状态进程上台，而不涉及唤醒阻塞的进程。</font>

<font color=orange>考研原题多一个“某进程退出临界区”，是可能将进程唤醒的事件。</font>

（2）

<img src=".\assets\image-20241015212750802.png" alt="image-20241015212750802" style="zoom:80%;" />

<font color=orange>想到一个问题，D的情况下，那谁去唤醒这些阻塞的进程？</font>

（3）

FIFO、短作业、优先权、时间片、银行家算法都是考试要求掌握的计算。

（4）

<img src=".\assets\image-20241015213351119.png" alt="image-20241015213351119" style="zoom:80%;" />

<font color=orange>用户态到核心态的转换是CS段寄存器的最后两位从11切成00，装入CS是由中断隐指令做的，是硬件做的。</font>

<font color=orange>核心态到用户态的转换是中断处理程序的内联汇编指令做的，是软件做的。</font>

（5）

<img src=".\assets\image-20241015214017551.png" alt="image-20241015214017551" style="zoom:80%;" />

<font color=orange>A：若R1=0，除数为0--异常；B：INT 80--自陷；D：按位取反，不会进入核心态；D：addr地址溢出--异常</font>

（6）中断控制器不是按照接收中断请求的先后次序进行中断优先级排队，是根据固定的管脚序号作为优先级来比较。

（7）在本课程的unix中，叫做中断入口程序+中断处理程序（处理程序是入口程序的一部分），在408考研中，统称为中断服务程序（或中断处理程序）。

（8）CPU执行应用程序时（代表其在用户态），在开中断的前提下，系统会响应任何到来的中断（因为处理机优先级是0）。

（9）进程执行信号量的P操作 ：P（wait）操作表示进程请求某一资源，所以会变成阻塞状态。这句话是在进程的三种状态那一节做的，学了后面就会知道，PV操作嘛就是，P操作无法进入，就会变成阻塞状态等待。

（10）<img src=".\assets\微信图片_20241026170415.jpg" style="zoom:80%;" />

这道题学了后面也是可以理解的，虚拟存储管理不是必须的，UNIX V6++就没有做虚存。



# 第三章 存储管理

<img src=".\assets\image-20241015215931161.png" alt="image-20241015215931161" style="zoom:80%;" />

寄存器和主存储器又称为可执行存储器。

高速缓存的建立是为了缓解主存与CPU寄存器速度差异的矛盾。根据程序局部性原理(即程序在执行时,将呈现出局部性规律,在较短的一段时间内,程序的执行仅局限于某个部分),将主存中一些经常访问的信息存放在**高速缓存**中,减少访问主存储器的次数,可以大幅提高程序的执行速度。同理,**磁盘缓存**是为了缓解内存与磁盘之间的速度差异。将频繁使用的一部分磁盘数据,暂时存放在主存空间中开辟的磁盘缓存中,可减少访问磁盘的次数。

## 存储管理的主要任务

### （一）主存空间的管理

#### （1）空闲空间的管理

**三种内存空间管理方式：索引表、链式队列与位示图**

链式队列：扫描链表速度比较慢，为提高查找空闲单元的速度，可以将空闲分配单元和被占用空间分开设置链表，形成两个链表的管理模式，同时，队列也可采用循环勾连构成循环队列

位示图：每一格是固定分配单元的大小

注意，位示图每一个数字占用的是1bit，所以8个bit才是1B，单位换算时要注意除以8才得到以B为单位。

<img src=".\assets\image-20241029220709122.png" alt="image-20241029220709122" style="zoom:50%;" />

<img src=".\assets\image-20241016155315023.png" alt="image-20241016155336884" style="zoom:50%;" />

#### （2）空闲空间的分配

**两种内存分配方式：连续分配方式和离散分配方式**

### （二）地址变换

创建进程的一个重要工作,就是将该进程所需的程序和数据装入内存。将一个用户源程序变成一个可以在内存中执行的程序,通常要经过以下三个步骤：
(1)编译。由编译程序(Compiler)将用户源代码编译成若干个目标模块。
(2)链接。由链接程序(Linker)将编译后形成的一组目标模块,以及它们所需要的库函数链接在一起,形成一个完整的装入模块。
(3)装入。由装入程序(Loader)将装入模块**装入内存**。

:star2:逻辑地址在链接阶段生成，物理地址在装入或者执行阶段生成。

程序员编写程序不能用内存物理地址，而应该使用在逻辑上独立于机器的地址**从0开始**在地址字长允许的范围内编写程序。这种地址称为逻辑地址或程序地址。它们构成的地址空间相应地称为逻辑地址空间或程序地址空间。与内存的实地址相对应。程序地址有时也叫虚地址，相应空间叫虚地址空间，内存物理地址构成的空间称为物理地址空间或内存空间。

:star2:不同进程可以有相同的逻辑地址，因为相同的逻辑地址可以映射到主存的不同位置。

程序员本身在用高级语言编写程序时，并不涉及地址编码的问题，而是由编译程序、链接程序等负责处理。在“装入”阶段，装入内存，会发生逻辑地址向物理地址的转换，这种变换过程叫做地址重定位。

:star2:用户程序和程序员只需要知道逻辑地址，而内存管理的具体机制则是完全透明的。所以在程序中打印的地址都是逻辑地址。

有两种地址重定位：

（1）静态地址重定位：由装配程序在**装入**时完成

静态重定位的优点是**不需要硬件的支持,**因而可以在任何机器上实施。

它的主要缺点是:①**程序必须占用连续的内存区,而且在执行过程中不能移动**。这不利于内存空间的有效利用。②各个进程难以共享在内存中的同一程序副本。

（2）动态地址重定位：程序**执行**中动态完成

（装入程序将装入模块装入内存后，并不会立即将装入模块中的相对地址转为绝对地址，而是将这种地址转换推迟到程序真正要执行时才进行）

在程序运行过程中，每次访存之前，将程序地址变换成内存地址，这种变换是依靠**硬件**地址变换机构实施的。利用“**地址变换机构**”，在处理机中设置基地址寄存器，虚地址寄存器和内存地址寄存器，每次把虚地址寄存器和基地址寄存器相加，结果送入内存地址寄存器，按内存地址寄存器值访存。

动态重定位的优点是:①程序占用的内存空间动态可变,也不必分配连续内存空间;②几个进程比较易于共享使用同一程序副本。

动态重定位的代价是:①实现存储管理的软件算法比较复杂;②需要一定的硬件支持。

**现代操作系统采用的地址重定位方式是动态重定位**。

<img src=".\assets\image-20241016162023858.png" alt="image-20241016162023858" style="zoom:50%;" />

### （三）内存扩充

现代计算机系统可能出现的情况：

单个进程所需内存空间 > 物理内存；大量并发进程所需空间总和 > 物理内存。

早期存储管理方式的特征：
(1)一次性特征：**作业在运行前，需要一次性地全部装入内存**。而正是这一特征导致了上述两种情况的发生。而实际情况,有许多作业在运行时,并非其全部程序和数据都要用到。如果一次性装入全部数据,是对内存空间的浪费。
(2)驻留性特征：**作业装入内存后，便一直驻留在内存，直至作业运行结束**。尽管运行中的进程会因 I/O而长期等待，或有的代码在运行过一次后将不再需要运行了，但它们将继续占用宝贵的内存资源。

所以需要内存扩充：在不增加实际物理存储空间的条件下，借助大容量的辅存，在逻辑上实现对内存的扩充。

#### （1）覆盖

**打破一次性。**

一个作业的若干程序段共享一段主存空间。一个覆盖段内的多个程序段按先后次序依次进入内存，后进入的程序段覆盖之前进入的程序段。

<img src=".\assets\微信图片_20241016162956.jpg" style="zoom:33%;" />

子程序1和子程序2是**不会同时执行的两个程序段,因而可以将两个程序段构成个一覆盖段**,并共享一段 10k大小的覆盖区。执行子程序1时,将子程序1装入该覆盖区,当子程序2执行时,子程序2的装入将覆盖子程序1。同理,子程序11、子程序21和子程序22**也构成了一个覆盖段**,并共享一个25k的覆盖区。如果加上主程序需要的30k内存区域整个作业的执行一共需要 65k的内存空间,比未采用覆盖技术而为所有的程序分配内存空间所需的 108k有了大幅度减少。

覆盖技术的关键是提供正确的覆盖结构。通常,一个作业的覆盖结构要求**程序员事先给出**,这相当于**把内存管理的部分功能交给了用户,是个很糟糕的方法**。对于一个规模较大或比较复杂的程序来说是难以分析和建立它的覆盖结构的。因此,通常**覆盖技术主要用于系统程序的主存管理上**。例如,磁盘操作系统分为两部分,一部分是操作系统中经常用到的基本部分,它们常驻主存且占有固定区域;另一部分是不经常用的部分,它们放在磁盘上,当调用时才被装入主存覆盖区中运行。


#### （2）交换

**打破驻留性**

进程的全部或部分图象可在内外存间移动。

①以进程的全部图象为单位：把内存中暂时不能运行的进程的全部进程图象调出到外存，腾出足够的内存空间，再把具备运行条件的进程调入内存。

②以进程的部分图象为单位：如：以“页”或“段”为单位。是请求分页和请求分段式存储管理的基础，其目的是为了支持虚拟存储系统。

**程序的物理地址在执行的过程中可能发生改变，所以必须使用动态地址重定位。**

交换的时机：①作业的进程用完时间片或者等待IO ②作业要求扩充存储空间而得不到满足时。

:star2:举例作业要求扩充存储空间？

堆:用来存放动态分配的变量。通过调用malloc函数动态地向高地址分配空间。
栈:用来实现函数调用。从用户空间的最大地址往低地址方向增长。
代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样。当调用像malloc和 free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。用户栈在程序运行期间也可以动态地扩展和收缩，每次调用一个函数，栈就会增长;从一个函数返回时，就会收缩。



#### （3）虚拟存储器

从逻辑上扩充内存。

与覆盖类似的是：一个作业在执行时, 只需一部分地址空间在主存，另一部分在辅存。在辅存的地址空间将来通过请求调入功能，陆续进入主存时，并有可能覆盖主存中的地址空间（对程序员透明）。

与交换类似的是：一个作业在执行时，部分地址空间可以经由置换功能，在内存和外存之间移动（以“页”或“段”为单位，**对程序员透明**）。

虚拟存储器具有**请求调入**和**置换功能**，从逻辑上对内存容量加以扩充。 **其逻辑容量由内存容量和外存容量之和决定，速度接近于内存速度，成本接近于外存**。

:star2:内存的物理存取速度是由硬件决定的，不可改变。通过虚拟存储器提高的是数据的逻辑存取速度。

虚拟存储器具有三大主要特性：

①多次性：一个作业被分成多次调入内存运行。

②对换性：允许在作业运行过程中进行换进、换出。

③虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远远大于实际的内存容量。



### （四）信息共享与保护

信息共享：多个进程可以共享一块内存空间 

信息保护：进程只能在分配给它的存储区内活动

- 上下界寄存器

  用这两个寄存器分别存放**进程地址空间的起始地址和结束地址**。在进程执行过程中,将每一个访问内存的地址都与这两个寄存器的内容比较,如超出这个范围便产生保护性中断。

- 基址、限长寄存器

  用这两个寄存器分别存放**进程地址空间的起始地址和地址空间长度**。当进程执行时,将每一个访问内存的相对地址和限长寄存器比较,如果超过了限长寄存器的值,则发出越界中断信号,并停止进程的运行。

<img src=".\assets\image-20241016165418290.png" alt="image-20241016165418290" style="zoom:50%;" />

:star2:设置的这些寄存器就是硬件，所以内存保护需要硬件与软件的配合。

:star2:重定位寄存器必须使用特权指令，只有操作系统内核才能修改，不允许用户程序修改。



## 连续分配方式

都是**一个用户程序占用一个连续的内存空间**。

### （一）单一连续分配

最简单，只适用于单用户、单任务的系统。（机器由一个用户独占）

地址变换：静态地址重定位（其可独占的地址空间范围是事先设计好的）

内存保护：越界保护或没有（不可能存在其他用户干扰问题，可能出现的破坏行为也只是用户程序自己去破坏操作系统，其后果并不严重）

### （二）固定分区分配

最简单的一种可运行多道程序的存储管理方式。

分配方式：将内存用户空间划分为若干个固定大小的区域，在每个分区中装入一道作业。

- 分区大小相等
- 分区大小不等

内存扩充：可采用覆盖和交换技术实现内存扩充。

地址变换：静态/动态地址重定位。

内存保护：利用界限寄存器实现越界保护。（支持多道程序并发执行就必须对内存进行保护）

:star2:分区大小是固定的，如果与程序的大小不匹配，分区就会得不到利用。必然会造成存储空间的浪费，因而现在很少用于通用计算机中。但在某些用于控制多个相同对象的控制系统中，由于每个对象的控制程序大小相同，是事先编写好的，其所需的数据也是一定的，故仍采用固定分区式存储管理方式。



### （三）可变分区分配

<img src=".\assets\image-20241016181613040.png" alt="image-20241016181613040" style="zoom:50%;" />

空闲分区表是按照起始地址排列的。

会出现很小的、难以利用的空闲分区，叫做碎片。

可变分区又叫做动态分区，是在系统运行过程中在作业装入时动态建立的。

地址变换：地址变换机构（基地址寄存器）。

内存扩充：可采用覆盖和交换技术实现内存扩充。

内存保护：利用界限寄存器实现越界保护。

#### 分配算法

以下四种分配算法都是基于顺序搜索。

##### （1）首次适应算法First Fit

按空闲分区首地址升序排列。

- 从第1个空闲区开始顺序找， 直至找到一个大小满足要求的空闲分区。

- 从该分区中划一块给请求者， 余下的仍留空闲分区表中。

特点：优先利用内存中低地址部分的空闲分区，从而保留了高地址部分的大空闲区，为以后到达的大作业分配大的内存空间创造了条件。缺点是矛盾和碎片集中在低地址部分，矛盾是指每次查找时都是从低地址部分开始的，会增加查找可用空闲分区的开销。

##### （2）循环首次适应算法Next Fit

按空闲分区首地址升序排列。

- 从上次找到空闲分区的下一个空闲分区开始查找（采用循环查找方式）。

- 从该分区中划一块给请求者，余下的仍留空闲分区表中。

特点：内存的空闲分布的更均匀，从而减少了查找空闲分区时的开销；缺点是缺乏大的空闲分区。

<img src=".\assets\image-20241016182834208.png" alt="image-20241016182834208" style="zoom:50%;" />

##### （3）最佳匹配算法Best Fit

按空闲分区大小升序排列。

- 从第1个空闲区开始顺序找，直至找到一个大小满足要求的空闲分区。
- 总把能满足要求，又最小的空闲区分配给进程。

特点：避免大材小用，但碎片小，且维护存储空间按大小的有序排列需要额外的开销。

##### （4）最坏匹配算法Worst Fit

按空闲分区大小降序排列。

从第1个空闲区开始顺序找总把能满足要求，又最大的空闲区分配给进程，**产生碎片的几率最小**。

特点：查找时只需要看第一个分区是否能满足需求，若不满足则没有分区能够满足。查找效率高，但缺大分区，且维护存储空间按大小的有序排列需要额外的开销。

<img src=".\assets\image-20241016183402827.png" alt="image-20241016183402827" style="zoom:50%;" />

:star2:最容易产生内存碎片的算法是**最佳匹配算法**，因为该算法总是匹配与当前大小要求最接近的空闲分区，但是大多数情况下空闲分区的大小不可能完全和当前要求的大小相等，几乎每次分配内存都会产生内存碎片。

#### 分配操作

<img src=".\assets\image-20241016183556279.png" alt="image-20241016183556279" style="zoom:67%;" />

用size消除碎片，不用再维护。

#### 内存回收

<img src=".\assets\微信图片_20241016220752.jpg" style="zoom:50%;" />

有相邻的就连在一起，如果上下都相邻就都拼一起。

关注起始地址和内存大小两个值是否都需要修改。

:star2:碎片是不可避免的。

### （四）可重定位分区分配

<img src=".\assets\image-20241016221046716.png" alt="image-20241016221046716" style="zoom:50%;" />

紧凑的作用：集中空闲区。

流程是先判断利用可变分区方式进行分配时空闲区是否有能放下当前进程的，如果没有，则相当于现在所有的空闲区都太小了，都看作碎片，所以去算空闲分区内存大小之和是否大于当前进程请求大小，如果大于，那就紧凑，如果小于，就失败了。

紧凑尽管可以解决碎片的问题， 但是代价较高，需要大量的内存复制，改变很多相关的数据结构。后续会学，如果可以将用户程序离散装入不连续的内存空间，就可避免紧凑。

### 总结四种连续分配方式

<img src=".\assets\image-20241016221550231.png" alt="image-20241016221550231" style="zoom:50%;" />

## 页式存储管理

### 地址变换

#### 页和页框

页：把每个程序的连续**逻辑地址**空间划分成若干大小相等的页。

页框：主存空间**物理地址**划分成相同大小的块。（又叫物理块）

在为进程分配内存时，以页为单位，每页分别装入一个页框。

由于进程的最后一页经常装不满，从而形成了碎片，这时**内存中的碎片大小不会超过一页**，称为页内碎片。

:star2:虽然在课上就叫碎片，但也可以区分一下：固定分区会产生内部碎片，动态分区会产生外部碎片，分页存储会产生页内碎片。

:star2:页面大小应该是2的整数次幂，以便进行地址转换。页面大小应该**适中**，页面太小会使进程中的页面数过多，这样**页表就会太长**，占用大量内存，也会增加硬件地址转换的开销，降低页面换进/换出的效率；页面过大又会使**页内碎片增多**，降低内存的利用率。

分页存储管理中的程序地址字结构：页号P+页内偏移地址W

每个页的页内偏移地址都是从全0到全1，页长是2^n^，则页内偏移地址就是n-1位到0位。

:star2:页号是商，偏移地址是余数，没有加一减一的操作。首位是0号页第0个。

<img src=".\assets\image-20241018145311434.png" alt="image-20241018145311434" style="zoom:50%;" />

1024正好是1号页的第0个。eg. 若页的大小1K，A＝2170，则P=2，W=122

:star2:把程序地址空间分成页号和页内地址是由**硬件**实施的（硬件做好的，**页内大小不可更改**），对程序员是完全透明的。程序员只知道他在一个**相当大的一维线性地址空间**中编写程序。所以每当CPU需要形成一个有效的地址时，都要查找页表这件事是**硬件自动**完成的。

:star2:对主存的访问是以字或字节为单位的；对主存的分配是以页框为单位的。

#### 页表

页表是由**操作系统**在程序**装入**内存时建立的。分页管理是**硬件和操作系统层面**实现的（页表由操作系统建立，查找页表由硬件实现），对**用户、编译系统、装配程序等上层**是不可见的。

:star2:如果页面大小512B，虚拟地址32位，物理地址16位，采用单级页表，则页表共有2^23^个页表项。**页表项数量与物理地址的位数没有必然关系**。是根据逻辑地址来计算的。

在进行地址变换时，页号改变，页内偏移地址不变。

**利用页表实现页号到物理页框号的映射。**

页表的内容：内存页框号+特征位。

因为页表总是按照页号从小到大排序的，所以页号不用存储在页表中。特征位是“可读”、“读写”、“只执行”等存取方式。

页表在内存中（所以每次查表要访存），**每个进程有一个页表**，把页表的起始地址和页表长度存在进程控制块PCB中。系统中有**一个**页表寄存器PTR，当进程被调度上台时，这两个数据被装入页表起始地址寄存器、页表长度寄存器，CPU只知道当前台上的进程页表在哪。因此在单处理机环境下，虽然系统可以运行多个进程，但只需要一个页表寄存器。

地址变换的过程：

1. 地址越界保护：用CPU的页表长度寄存器去检查程序逻辑地址的页号，如果页号大于页表长度，则发生越界。
2. 根据逻辑地址的页号和寄存器里的页表首址，找到对应的页表项。
3. 越权保护：根据特征位确定是否为访问非法，如果越权，会触发中断。
4. 用页框号代替页号，获得物理地址。

<img src=".\assets\image-20241018151025702.png" alt="image-20241018151025702" style="zoom:50%;" />

### 空闲页面的管理

<img src=".\assets\image-20241018151136457.png" alt="image-20241018151136457" style="zoom:50%;" />

### 快表TLB

为了提高地址变换速度，可增设一个特殊高速缓冲寄存器：“快表”，用以存放当前访问的那些页表项。（也叫相联存储器）

此时的地址变换过程是：

在CPU给出有效地址后,由地址变换机构自动将页号P先送入快表，并将此页号与快表中的所有页号进行比较，若其中有与此相匹配的页号，则称之为“命中”（cache命中），表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，以便形成物理地址。

如在快表中未找到相应的页表项,即“未命中”,则还需再访问内存中的页表以进行地址变换。若快表“未命中”，在地址变换结束后，需将内存页表中的相应页表项存入快表中的一个寄存器单元中，即更新快表。如果快表已满，其控制单元必须找到一个最老的且已被认为不再需要的页表项,将其换出。

由于成本的关系,快表不可能做得很大,通常只保存16~512个页表项。由于程序和数据的访问往往带有局部性（局部性原理：时间局部性，空间局部性），因此，据统计，从快表中能找到所需页表项的概率可达 90%上。这样，由于增加了地址变换机构而造成的速度损失，可减少到 10%以下，达到了可以接受的程度。

:star2:页表不用存页号，但是快表需要存页号。

:star2:快表的本质是寄存器，在CPU里，不用访存。所以如果在TLB找到，则访存一次；没找到，则访存两次。

### 虚拟存储器

虚拟存储技术基于程序的局部性原理。局部性越好，虚拟存储越能发挥作用。

具有**请求调页功能**和**页置换功能**，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和决定，速度接近于内存速度，成本接近于外存。

- 程序运行前，不必全部装入内存，只需将当前要运行的少数页面先装入内存便可运行。 
- 程序运行时，如果要访问的页已在内存，则继续执行。否则，利用请求**调页功能**，将它们调入内存。
- 若此时内存已满，则利用**页置换**功能，将内存中暂时不用的页调出，腾出空间后，再将需要的页调入。

建立在基本分页存储管理方式基础之上，叫做**请求分页系统**。请求分页是目前最常用的一种实现虚拟存储器的方式。

虚拟存储器的最大容量要满足两个条件：

①≤内存容量+外存容量之和

②≤计算机的地址位数能容纳的最大容量（假设字节编址，地址32位，则虚存的最大容量4GB）

#### 扩展的页表

页表变成：内存页框号+外存地址+特征位。

- 外存地址： 该页保存在外存的起始地址 

- 特征位： 
  - 存取方式：对该页的访问权 
  - 状态位P：该页是否在内存； （做了虚存才会出现P=0的情况，UNIXV6++就没做虚存，P就始终等于1）
  - 修改位M：该页是否被修改过； （是：要写回磁盘；否：直接覆盖）
  - 访问位A：对该页的使用情况； （使用频率、最近已经多久未被访问）
  - 该页是否需常驻内存（用于判定是否能够被换出内存）

新页进入内存后，都需要修改页表中的相应表项，填写分配到的内存页框号，置其存在位为1，初始化访问位和修改位。

具体如下：

<img src=".\assets\image-20241030121807225.png" alt="image-20241030121807225" style="zoom:80%;" />

0x27CA：该逻辑地址对应的页号是2，页内偏移地址是0x7CA，由逻辑页号2查表可知，该逻辑页不在内存。会引发缺页中断，缺页中断的处理过程如下：

①（选换出页）由于采用FIFO算法，可知选择0号页换出；

②（回写脏页）由于0号页在内存中曾经被修改过，因此需启动I/O操作将0号页写回磁盘上0x2000开始的8个盘块中；

③（读入新页）启动I/O将0x2016开始的8个盘块的内容读入0x100号物理页框； 

④（修改页表）修改页表如下：

<img src=".\assets\image-20241030123642172.png" alt="image-20241030123642172" style="zoom:50%;" />

⑤（形成地址）0x27CA → 0x1007CA

注意，题干是“读取”，所以修改位是0，如果是“写入”，那么修改位就是1。因为从外存拿过来的是原始数据，写入相当于更改了，所以到时候要写回外存。

#### 地址变换机构 

地址变换的过程：

1. 地址越界保护：用CPU的页表长度寄存器去检查程序逻辑地址的页号，如果页号大于页表长度，则发生越界。

2. 根据逻辑地址的页号和寄存器里的页表首址，找到对应的页表项。

3. 根据特征位确定是否为访问非法，如果越权，会触发中断。

   根据状态位P判断该页是否在内存，在：修改访问位A

   ​                                                            不在：产生缺页异常

4. 用页框号代替页号，获得物理地址。

:star2:根据状态位P判断该页是否在内存时的流程都是**硬件**做好的，只有缺页异常是在等待**软件**解决。缺页异常是**软中断**，CPU自己产生的，不是来自于中断控制器。

:star2:注意顺序，所以在缺页时，操作系统执行的操作不可能是处理越界错，因为如果越界系统在第一步就终止了。

#### 缺页中断机构 

<img src=".\assets\image-20241018153526633.png" alt="image-20241018153526633" style="zoom:50%;" />、

在缺页中断时最多会有两次IO操作（其实是两批，因为可能不止一页）

:star2:所谓的“内存满”，不是整个内存，而是它能够占用的内存。

- 固定分配，局部置换：现在一般用这种

  为每一个进程分配一定数目的物理块，在整个运行期间不再改变。如果进程在运行中发生缺页（指的是分配的这些内存满了），只能从分配给它的n个页面中选择一个换出，然后再调入一页。

- 可变分配，全局置换：

  先为系统中的每个进程分配一定数目的物理块，而操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，由系统从空闲物理块队列中取出一个分配给该进程。这样，凡产生新缺页中断的进程，都将获得新的物理块。仅当空闲队列分配完时，操作系统才会从内存中选择一页调出，而该页可能是系统中任一进程的页。
  
- 可变分配，局部置换：

  在固定分配局部置换基础上，如果某个进程在运行中频繁地发生缺页中断，则系统再为该进程分配若干附加的物理块。反之,如果某进程在运行过程中的缺页率非常低，则此时可适当减少分配给该进程的物理块数。

:star2:没有“固定分配，全局置换”。对各进程进行固定分配时页面数不变，不可能出现全局置换。

:star2:一些情况的分析：

（1）CPU利用率13%，磁盘利用率97%：说明在任务作业不多的情况下，交换操作非常频繁，页式存储目前没有发挥作用。因此判断物理内存严重短缺，要**增大内存容量**；系统现在已经处于频繁换进换出，如果再增加多道程序的度数，只会导致更频繁，所以要**减少多道程序的度数**；此时CPU的利用率不高，所以使用更快速的CPU对于提高CPU的利用率是无济于事的。

（2）CPU利用率87%，磁盘利用率3%：系统正常。

（3）CPU利用率13%，磁盘利用率3%：CPU没有充分利用，应该增加并发进程数。

#### 页面置换算法

最重要的需求是快，而不是严格追求算法上的最优。

:star2:抖动是进程的页面置换过程中，频繁的页面调度（缺页中断）行为，所有的页面调度策略都不可能完全避免抖动。

:star2:计算缺页异常和页面置换的次数时，注意分清，缺页异常（页面失效）是没找到；页面置换是把别人换出去。要注意，对于第一次查找也是缺页异常。

##### 最佳置换算法

理论上的最佳算法。其所选择的被淘汰页面，将是以后永不使用的，或许在未来最长时间内不再被访问的页面。会有最低的缺页率。但是在实际使用中，无法预知哪一页未来最长时间内不再访问。

<img src=".\assets\image-20241018154308123.png" alt="image-20241018154308123" style="zoom:50%;" />

##### 先进先出（FIFO）置换算法

其总是淘汰最先进入内存的页面。 

:star2:注意：如果新来的页面本来就在页框，不改变FIFO顺序，不会把它变成最后一个来的。

简单，但不能保证经常访问的页面不被淘汰。

<img src=".\assets\image-20241018154425614.png" alt="image-20241018154425614" style="zoom:50%;" />

##### 最近最久未使用（LRU）置换算法

其总是淘汰最近最久未使用的页面。

:star2:注意：如果新来的页面本来就在页框，要改变LRU顺序，把它变成最近一个刚使用的。

<img src=".\assets\image-20241018154451297.png" alt="image-20241018154451297" style="zoom:50%;" />

需要记录一个进程在内存中的各个页面各有多少时间未被访问，以及快速的知道哪一页是最近最久未使用的页面，如果全用软件做太慢了，所以需要辅助的硬件支持。

严格的LRU太费时间，会有一些稍微降级的算法应用于实际。比如时间窗口：设置一个时间范围，找到第一个超过该范围的就结束查找。

:star2:**Belady异常**：指的是当可供分配的页帧数增加时，缺页中断的次数不降反增。FIFO有Belady异常的情况存在，但LRU不会出现该异常。

:star2:对于顺序执行的程序，缺页次数等于该程序占用的页数（因为顺序执行不会再次用到之前使用过的页，是依次向下的）。那么如果把页面尺寸增大一倍而且可容纳的最大页数不变，则缺页中断次数会减小。（因为页面大了，该程序占用的页数就少了）

### 两级页表

现代的大多数计算机系统,都支持非常大的逻辑地址空间(2^32^~2^64^)。在这种情况下页表就变得非常大,要占用相当大的内存空间。例如,对于一个具有 **32 位逻辑地址空间**的分页系统,规定**页面大小为4kB**,即2^12^B,则在每个进程页表中的页表项可达1M个之多又因为每个页表项占用至少一个字节,故每个进程仅其页表就要占用 1MB 的内存空间,而且还是连续的。

二级页表就是为把页表分页，离散存储，同样也要为页表再建立一个页表，叫做页目录（外层页表）

<img src=".\assets\image-20241018162941396.png" alt="image-20241018162941396" style="zoom:50%;" />

**直接拿x86的32位系统为例：**

页的大小是4K，（2^12^），所以页内偏移地址是12位，逻辑地址如果是4G的话，（2^32^），则会有2^20^个页表（1024*1024），每个页表4个字节，所以页表一共占了4M的内存，太大了，难以连续存储，所以想到离散存储，把页表进行分割，如果分成1024张页表，则正好一张页表的大小1024×4B=4K，恰好为一个页的大小，1024张页表需要页目录去存储，目录有1024条，每一条4个字节，1024×4B=4K，也恰好为一个页的大小。所以相当于把”在内存中找一块连续的4M空间存页表“变成了”在内存中找分散的1025个4K的页框存页表和页目录“，解决了页表太大难以存储的问题。

页目录在内存中占用的页框号保存在CPU内的寄存器CR3中，页目录叫PDE，页表叫PTE。

地址变化的过程变成：

1. 由寄存器CR3得到页目录所在的内存页框号
2. 将逻辑地址的高10位作为页目录中的偏移，得到相应的PDE
3. **根据该PDE得到对应页表的内存页框号**
4. 将逻辑地址的12~21位作为页表中的偏移，得到相应的PTE
5. 根据PTE得到对应逻辑页的内存页框号
6. 将这个内存页框号与逻辑地址中的低12位装配，便得到了物理地址。

<img src=".\assets\image-20241018231021386.png" alt="image-20241018231021386" style="zoom:50%;" />

<img src=".\assets\image-20241018214210766.png" alt="image-20241018214210766" style="zoom:70%;" />

10位K，20位M，30位G

32位数据=高10页目录+中10页表+低12偏移地址、

所以可以把给出的逻辑地址转成二进制表示，然后进行两种切分，就容易得到结果了。

可以看出，每4M对应一张页表，每4G对应一条页目录（当然，最大内存只有4G，最大只会到32位，3G多）。

:star2:若页表划分为N级，则需要访问内存N+1次。

总结：TLB命中：访问TLB1次+访存1次；

​            TLB不命中：访问TLB1次+访存2次；（要看更新TLB的时间是否忽略，如果不忽略还得加上）

​            N级页表：访存N+1次；

​            有虚存且缺页：先访存1次，发现缺页，完成磁盘交换1次（包括访问磁盘，放进内存，有的题目会区分页面置换时是否需要写回磁盘，这时会有两种时间，一种是置换+写回的时间，另一种是置换的时间），这时缺页中断完成，返回中断处指令，这时页表已经在内存，所以再访存2次完成。（这里的“再访存2次”针对的是只有虚存没有快表的情况，如果既有快表又有虚存，那么当缺页时，会直接把从磁盘取来的页同时放进内存和快表，所以中断结束后返回之后只需要访问快表+访存1次就可以了）

:star2:两级页表并未减少页表所占用的内存空间，只是解决了大页表需要大片存储空间的问题。

:star2:在采用两级页表的情况下，对于正在运行的进程，必须将其页表目录调入内存，而对页表只需要调入一页或几页。

### 总结分页系统优缺点

分页系统与之前的可变分区分配方式相比,主要的优势体现在以下三个方面：

1. 不需要“紧凑”过程就可解决零头问题,将碎片控制在一页之内,有效地提高了主存的利用率。
2. 可提供大容量的虚拟存储器,方便了大作业用户。
3. 多道程序运行的程度进一步提高。

而分页系统也同时存在一些不足之处，比如：动态的地址变换机构，增加计算机的成本，降低处理速度；系统为维护各种表格需花费额外空间、时间；在请求分页系统，为处理页面中断增加了系统开销。

## UNIX存储管理

### 程序地址空间

理论上32位逻辑地址提供了4G的逻辑地址空间，但是出于小型化和易于实现的考虑，UNIX V6++中对进程可访问的逻辑地址空间做了如下限制：

用户态[0,8M-1]的逻辑地址空间，共8M字节

核心态[3G,3G+4M-1]的逻辑地址空间，共4M字节

<img src=".\assets\image-20241027185318461.png" alt="image-20241027185318461" style="zoom:80%;" />

前4M+4K是编译器预留部分（编译原理课程内容，本课程不讲），从4M+4K开始是代码段+数据段+堆栈段，每个段的长度都是4K的整数倍。

进程刚开始运行时，是有代码和数据的，所以按照4K整数倍向上取整分配代码段和数据段大小，而堆栈段这时是只有main栈帧的，所以初始只分配4K。

注意，堆栈段是从高地址向低地址压栈，所以栈底在8M-1，默认条件下，分配一张初始堆栈页面 （第2047#逻辑页）。随着程序嵌套调用的层次增加，可动态追加新的页面。代码段长度不变，内容不变（因为不允许更改），数据段长度变（unix的动态分配空间的系统调用）内容变（变量的值可以随着进程运行而改变）。

<img src=".\assets\image-20241025145742918.png" alt="image-20241025145742918" style="zoom:80%;" />

核心态3G~3G+4M-1，1M的保留区，0.5M的内核，0.5M的内核堆对象和2M的页表区，页表区的最后一个页是PPDA区。内核指的是操作系统内核代码和静态数据结构，内核堆对象指的是UNIX V6++内核重载了new/delete操作符，所有内核对象需要的内存空间全部来自这个内核堆，即存放着所有内核对象。

<img src=".\assets\image-20241025145728247.png" alt="image-20241025145728247" style="zoom:80%;" />

UNIX V6++只用了x86的1024张页表中的3张，再加上一张页目录，一共用了4个页框。

### 物理地址空间

<img src=".\assets\image-20241025145636038.png" alt="image-20241025145636038" style="zoom:80%;" />

### 地址变换

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20241025150409113.png" alt="image-20241025150409113" style="zoom:80%;" />

s/u指的是用户态or核心态，用户态为1。

r/w指的是可读or可写，为0是只读（代码段），为1是可读可写（数据段+堆栈段）。

p是是否在内存，因为UNIX V6++没有设置虚拟存储器，所以该项始终为1。

0号页表和1号页表中的每一个页其排列顺序是按照逻辑地址依次排列的，虽然在物理地址中，数据段和堆栈段是连续的，但在逻辑地址中，堆栈段在初始状态下是占据的8M内存中最后一个4K，是和数据段不连续的，所以在数据段和堆栈段之间会有省略号。即，页表的顺序取决于逻辑地址，页框号的内容取决于物理地址。

<img src=".\assets\image-20241025151337154.png" alt="image-20241025151337154" style="zoom: 80%;" />

核心态的4M，除了PPDA，其他的内容都是在系统生成、初启后就固定了，不再变化，它们的地址转换就是从逻辑地址的3G挪到了物理地址的0，是平移，相对位置不变。而在物理地址中，页表下面剩下的那一个页框，空着。PPDA会放到物理地址的4M之后去，内容随着现运行进程的不同而变化。

<img src=".\assets\image-20241025154904787.png" alt="image-20241025154904787" style="zoom:50%;" />

用户态和核心态的地址变换是靠页表来完成的，而页表又是核心态的一部分，从物理地址的2M开始是页表，占2M。物理地址的分页叫页框，根据下图可以知道，2M是0x200号页框（是十六进制！写的时候千万不能写成200，会默认成十进制！一定要写0x200）。页表的号是根据逻辑地址的顺序排的（0号1号，768号）；页框的号是根据物理地址排的，，2M是0x200号）。

<img src=".\assets\image-20241018214210766.png" alt="image-20241018214210766" style="zoom:70%;" />

每4M是一张页表，这个4M指的是地址空间大小。

物理页框号就是按照4K一个页框排列下去的，那么结合上图4M+256K就是0x440号页框（十六进制！）， 而这个0x440就是写在页表里的“内存页框号”的内容。

<img src=".\assets\image-20241025160641807.png" alt="image-20241025160641807" style="zoom:80%;" />

<img src=".\assets\image-20241025160716972.png" alt="image-20241025160716972" style="zoom:80%;" />

<img src="assets/image-20241025160737150.png" alt="image-20241025160737150" style="zoom:80%;" />

拿代码段4M+128K举例

此刻让我们再回顾之前的地址变化的过程：

1. 由寄存器CR3得到页目录所在的内存页框号

   <font color=orange>得到的是0x200号</font>

2. 将逻辑地址的高10位作为页目录中的偏移，得到相应的PDE

   <font color=orange>PDE指的是页目录中的项，逻辑地址是4M+4K，那么逻辑地址高10位就是0000 0000 01，所以得到的是页目录中的1#</font>

3. 根据该PDE得到对应页表的内存页框号

   <font color=orange>来到页目录的1#，得到内存页框号0x203，指的是物理地址的0x203号页框（1号页表）</font>

4. 将逻辑地址的21~12位作为页表中的偏移，得到相应的PTE

   <font color=orange>逻辑地址是4M+4K，那么逻辑地址12~21位就是0000 0000 01，所以得到的是1号页表中的1#</font>

5. 根据PTE得到对应逻辑页的内存页框号

   <font color=orange>来到1号页表的1#，得到内存页框号0x420</font>

6. 将这个内存页框号与逻辑地址中的低12位装配，便得到了物理地址。

   <font color=orange>逻辑地址是4M+4K，那么逻辑地址低12位是全0，所以得到物理地址0100 0010 0000 0000 0000 0000，就是4M+128K</font>

<font color=red>总结一下：从CR3拿到是页目录的物理地址，在UNIX V6++中，只有一张页目录，存在物理地址0x200号页框，所以从CR3取出的一定是0x200000。逻辑地址的高10位对应的是这张页目录中的第几项，指向的是0项、1项或者768项，定位到项后取出内存页框号，如果是0项那得到的就是0x202,1项是0x203,768项是0x201。用这个内存页框号来到页表，逻辑地址的21~12位对应的是这张页表中的第几项。来到该项得到一个内存页框号，再和逻辑地址的低10位拼接，就得到了物理地址。</font>

<img src=".\assets\image-20241025164305273.png" alt="image-20241025164305273" style="zoom:80%;" />

以上介绍的都是正在台上的进程，那么如果进程不在台上运行时呢？

进程在创建时，是变成就绪状态 ，paddr和caddr是未知的，所以假设二者都是0，创建了相对虚实地址映射表，在被用掉4个的页表区剩下的位置里面拿两个连续的页框放这个映射表。

:star2:为什么会存在相对表？其实它没有存在的必要，因为paddr，caddr和各个段的长度都是已知的，直接算就行了。存了相对表是因为在之前的系统还不是x86的时候，开发者是用了一些寄存器来存的相对表中这些东西，那么在应用于x86之后，为了系统兼容以及底层算法复用，选择了创建类似于之前寄存器的相对表，这样底层逻辑就不用改动了。

<img src=".\assets\image-20241025213820416.png" alt="image-20241025213820416" style="zoom:80%;" />

因为上台的进程，总是使用0号1号和768号页表，所以页目录在进程切换调度时是不需修改的。768号页表的前1023个页表项（核心态的4M除去PPDA区）是在进程创建时就固定的，后续也不会更改（此处的固定，更改 ，指的是在物理内存中的位置是固定的，不是其存储的内容是固定的）。需要在每次进程切换调度时修改的就是768号页表的最后一项（PPDA）和0号1号两张用户态页表。

<img src=".\assets\image-20241025214750143.png" alt="image-20241025214750143" style="zoom:80%;" />

注意，相对虚实地址映射表中红色的0和蓝色的1相连不是顺序下来的，是因为把paddr和caddr都设成了0且示例中代码段长度4K和PPDA区长度相等 才导致的。1025项放的是caddr，1026项放的是paddr+1。

下图的MemoryDescriptor是一个很重要的类，记录了相对虚实地址映射表的信息。m_UserPageTableArray是相对虚实地址映射表的逻辑地址，m_TextStartAddress是代码段的起始逻辑地址，m_TextSize是代码段长度，m_DataStartAddress是数据段的起始逻辑地址，m_DataSize是数据段长度，m_StackSize是堆栈段长度。

<img src=".\assets\image-20241025222147218.png" alt="image-20241025222147218" style="zoom:80%;" />

当进程上台时，利用相对虚实地址映射表刷新0号1号页表，利用r/w位来确定代码段、数据段和堆栈段的长度（这就是映射表的唯一功能）。

<img src=".\assets\image-20241025222443237.png" alt="image-20241025222443237" style="zoom:80%;" />

因此，现运行进程的完整进程图像又多了页表区的4张页框：3张页表+1张页目录。

因此题目若让绘制完整的进程图像：

<img src=".\assets\image-20241029202336892.png" alt="image-20241029202336892" style="zoom:80%;" />

#### 代码的共享

共享同一套代码的不同进程：

相对虚实地址映射表是一样的，因为两个进程具有完全相同的逻辑地址空间；

代码段物理页框号是一样的，因为x_caddr相同，是同一段代码；

进程图像的可交换部分物理页框号不同，因为paddr不同。

<img src=".\assets\image-20241026121417641.png" alt="image-20241026121417641" style="zoom:80%;" />

<img src=".\assets\image-20241026121439344.png" alt="image-20241026121439344" style="zoom:80%;" />

进程取指时，用的是代码段，所以逻辑地址经地址变化指向同样的物理地址；

两个进程在执行过程中，esp和ebp的值是一样的，因为之前讲的栈帧都是指的逻辑地址，但是，当ebp和esp经地址变化指向物理地址时，就是指向不同的物理地址了。

共享同一代码段的进程，其逻辑地址下完全相同，但因为其paddr不同（页表不同），在转换成物理地址后就分别指向自己的进程可交换区域了。

#### 进程的切换

之前讲的swtch，在进程下台时进行保存现场、选新进程、恢复现场，保存的是即将下台进程的核心栈的esp和ebp，存在User结构中的u_rsav[2]，恢复的是新上台进程的核心栈的esp和ebp，都是逻辑地址。而只有逻辑地址，不足以完成进程切换，实际上，还要通过换页表，来使得进程能够完成地址变换找到物理地址。

<img src=".\assets\image-20241026122410358.png" alt="image-20241026122410358" style="zoom:80%;" />

<img src=".\assets\image-20241026122426363.png" alt="image-20241026122426363" style="zoom:80%;" />

<img src=".\assets\image-20241026122439918.png" alt="image-20241026122439918" style="zoom:80%;" />

恢复现场的实际步骤是：**先为新进程建立核心态页表（只刷新768号页表的最后一项PPDA的paddr，只做这一件事）；再恢复u_rsav[2]数组中的esp和ebp；最后为新进程建立用户态页表（用相对表去刷新0号和1号页表）**

<img src=".\assets\image-20241026122722193.png" alt="image-20241026122722193" style="zoom:80%;" />

#### 现运行进程的图像

要解决的问题：如何跟踪现运行进程在两个地址空间的用户态下完整的进程图像

黑色是初始已知，红色是user获得，橘色是proc获得

|                    | 逻辑地址空间                                                 | 物理地址空间                                                 |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **代码段**         | **4M+4K**                                                    | **<font color=orange>u_procp->p_textp->x_caddr</font>**      |
| **数据段**         | **<font color=red>u_MemoryDescriptor. m_DataStartAddress</font>** | **<font color=orange>u_procp->p_addr+4K</font>**             |
| **堆栈段**         | **8M-4K**                                                    | **<font color=orange>p_addr+4K+u_MemoryDescriptor. m_DataSize</font>** |
|                    |                                                              |                                                              |
| **PPDA(USER)**     | **3G+4M-4K**                                                 | **<font color=orange>u_procp->p_addr</font>**                |
| **PROC**           | **<font color=red>u_procp</font>**                           | **<font color=red>u_procp-3G</font>**                        |
| **相对地址映射表** | **<font color=red>u_MemoryDescriptor. m_UserPageTableArray</font>** | **<font color=red>u_MemoryDescriptor. m_UserPageTableArray-3G</font>** |
| **物理页表**       | **3G+2M~3G+2M+16K**                                          | **2M~2M+16K**                                                |

调用GetUser()函数得到user结构的逻辑地址（UNIX V6++的进程 User 结构逻辑地址是固定的，始终位于 3G ~ 3G+4M 部分的最后一 页，即：0xC03FF000），从而获得u_procp（指向的是proc表）和相对地址映射表的逻辑地址，因为核心态的地址转换是平移，所以也就获得了物理地址，是逻辑地址-3G。

<img src=".\assets\image-20241026123851601.png" alt="image-20241026123851601" style="zoom:80%;" />

![image-20241026124129976](.\assets\image-20241026124129976.png)

从proc结构的逻辑地址开始，

获得paddr，有了paddr，就可以获得PPDA，数据段的物理地址，然后再加上获得了数据段的长度，就可以获得堆栈段的物理地址。

获得了p_textp，p_textp指向的是text表，text表中的x_caddr指向代码段的物理地址。

<img src=".\assets\image-20241026124520105.png" alt="image-20241026124520105" style="zoom:80%;" />

<img src=".\assets\image-20241026134417462.png" alt="image-20241026134417462" style="zoom:80%;" />

在进程的整个生命周期中，表格中哪些地址的值会发生变化？

逻辑地址：

- 只有堆栈段会变：如果程序执行过程中，堆栈深度不够，则追加4K。

物理地址：

- 堆栈段变化：一旦堆栈段长度发生变化，物理地址空间中的进程可交换部分**PPDA+数据段+堆栈段**会重新在内存找一块区域放置，所以三者的物理地址都会发生变化。

- 进程图像每次换进换出：paddr和caddr都会变，所以是**代码段+PPDA+数据段+堆栈段**的物理地址都会发生变化。

:star2:如果是连续主存管理方式，在V6++中，当堆栈段增长时，会重新为进程可交换部分分配内存；当堆栈段缩短时，不会回收，会保持原状（如果修改系统，就可以回收，重新分配内存）

当ESP=0x007ff000时，等于8M-4K，是4M大小堆栈段的顶，意味着堆栈段要增长为8M了。

- 申请分配4个连续物理页框，**起始页框号假设为new**；可交换部分复制到新空间；原有堆栈页向高地址区平移（复制）； 
- 修Process 对象：**p_size = p_size+4K，p_addr指向new起始的主存页框起始地址**； 
- **释放原有的内存空间**；
- 重填相对虚实地址映射表（**改最后的堆栈段**）和 memoryDescriptor（**改堆栈段长度**）；
- 重填页表（**把所有的paddr换成new，改1号页表最后的堆栈段**）。

<img src=".\assets\image-20241030222744040.png" alt="image-20241030222744040" style="zoom:30%;" /> <img src=".\assets\image-20241030222805559.png" alt="image-20241030222805559" style="zoom:30%;" />

<img src=".\assets\image-20241030222828007.png" alt="image-20241030222828007" style="zoom:35%;" /> <img src=".\assets\image-20241030222851241.png" alt="image-20241030222851241" style="zoom:35%;" />

如果是离散主存管理方式

- 申请分配1个物理页框，起始页框号假设为new；
- 修Process 对象：p_size = p_size+4K
- 重填相对虚实地址映射表（**在原有相对表的基础上，更改新加的那一页堆栈段的内存页框号为new-paddr>>12**）和 memoryDescriptor（**改堆栈段长度**）；
- 修正页表的2046# PTE（**变成堆栈段部分，内存页框号改为new**）。

<img src=".\assets\image-20241030223601766.png" alt="image-20241030223601766" style="zoom:30%;" />  <img src=".\assets\image-20241030223641787.png" alt="image-20241030223641787" style="zoom:33%;" />

### 存储空间管理

![image-20241026135127060](.\assets\image-20241026135127060.png)

内核堆对象、页表区、用户区叫做三个空闲分区，分别由三个类管理。

注意，页表区指的是除去页目录和一张核心态页表，两张用户态页表（共四张页框）以外的可分配页表。

内核堆对象对应 KernelAllocator类，页表区对应KernelPageManager，用户区对应 UserPageManager。

三个类中各有一个空闲分区表map。

<img src=".\assets\image-20241026140030293.png" alt="image-20241026140030293" style="zoom:80%;" />

三个类中各有一对空闲区分配和回收的函数，均采用可变分区方式中的首次适应算法进行分配，按照分四种情况考虑的方式回收。

<img src=".\assets\image-20241026140349582.png" alt="image-20241026140349582" style="zoom:80%;" />

进程创建时：

- 在页表区中申请两个连续的空闲页框，建立相对虚实地址映射表

- 按进程实际需求在用户区中申请连续内存

  和父进程共享已经在内存的代码段，所以实际需求= 可交换部分，代码段与可交换部分不连续

进程图像交换时：

- 换出进程释放曾经占用的内存

  进程可交换部分一定释放，代码段如果无进程共享才释放

- 为换入进程实际需求在用户区中申请内存

  - 第一个使用该代码段的进程：实际需求= 代码段+ 可交换部分，代码段与可交换部分连续

  - 共享一个已经在内存的代码段：实际需求= 可交换部分，代码段与可交换部分不连续

进程终止时：

- 在页表区中释放相对虚实地址映射表

- 进程释放曾经占用的内存

  进程可交换部分一定释放，代码段如果无进程共享才释放



# 第四章 进程管理

## UNIX时钟中断与异常

### 时钟中断

<img src=".\assets\image-20241106215705656.png" alt="image-20241106215705656" style="zoom: 50%;" />

之前讲过的中断控制器8259，外设之一就是时钟，是时钟芯片，PC中的可编程定时芯片8253或8254。在所有外设中，时钟的中断号是0x20，,中断优先级最高，所以一定会被相应。每秒定时中断60次，是系统的“心跳”。

<img src=".\assets\image-20241106220023655.png" alt="image-20241106220023655" style="zoom:67%;" />

Time::time是系统时间，记录从1970年1月1日以来以秒为单位的时间。

<img src=".\assets\image-20241106220142659.png" alt="image-20241106220142659" style="zoom:67%;" />

proc结构中：

<img src=".\assets\image-20241106220330253.png" alt="image-20241106220330253" style="zoom:80%;" />

<img src=".\assets\image-20241106220344555.png" alt="image-20241106220344555" style="zoom:80%;" />

p_time是进程图像换进换出的依据。当从盘交换区选择进程进入内存时，优先调入p_time最长的。·

user结构中：

<img src=".\assets\image-20241106220413891.png" alt="image-20241106220413891" style="zoom:80%;" />

进程用户态时间才是程序员代码占用的实际时间，不能把执行内核代码用的核心态时间也算进去。

#### 时钟中断流程

<img src=".\assets\image-20241106220637297.png" alt="image-20241106220637297" style="zoom:80%;" />

u_utime/u_stime：现运行进程分别在用户态和核心态下已经执行的心跳数的计数。

p_cpu：现运行进程在CPU上执行的心跳数的计数。

Time::lbolt ：系统时钟脉冲计数。

这些参数都是以时钟脉冲数为单位的，1/60秒。

该部分只需要完成三个加法，用时很短，所以一秒钟执行60次是没有问题的。

<img src=".\assets\image-20241106221106330.png" alt="image-20241106221106330" style="zoom:80%;" />

把EOI调整到这一部分了。

时间没有到1秒钟，后面的事情不用做。

中断前是核心态， 后面的事情不能做：**系统不会因为后续冗长的维护工作耽误核心态任务**



**1、维护系统时间**：Time::lbolt-60; 系统时间+1秒

改成： Time::lbolt==60?Time::lbolt=0 可以么？

不可以，改成这样，如果整数秒的时钟中断先前态是核心态，会漏掉这一秒计时。（应该是如果改成Time::lbolt是60的倍数就置0会漏掉吧，如果改成上面写的那个等于60再置零，一旦正好60在核心态导致提前返回之后，Time::lbolt就永远大于60了，永远不会系统加秒了。）

<img src=".\assets\image-20241106221623781.png" alt="image-20241106221623781" style="zoom:50%;" />

**不漏掉一次时钟脉冲，但不急于修改系统时间。**



**2、提前开中断**：开中断，向中断控制器发送EOI指令

发送EOI指令就会让8259以为中断结束了，处理机优先级就会降至0，这样其他的中断请求就可以进入。

**时钟中断中提前开中断，后续耗时的处理过程中，允许中断嵌套。**

原因是：由于时钟的优先级最高，且时钟中断包含了许多繁琐耗时的事务处理，如果在时钟中断的过程中，都不允许其他中断嵌套，则有可能会导致一些外设比较紧急的中断请求被延误。

时钟中断会在处理繁琐事务之前改变处理机优先级，降至最低，与一般的中断处理机中始终不改变处理机优先级的方式不同。一般处理机，比如磁盘中断时，处理机优先级始终保持高位（等于磁盘的中断优先级），不允许其他同级和较低级的中断请求嵌套。



**3、唤醒所有延时睡眠的进程**

有定时睡眠的，执行系统调用sleep(seconds)而入睡，seconds秒后系统需要将其唤醒。



**4、对所有进程p_time++**

注意是所有进程，包括在内存中的和在盘交换区的，因为p_time代表的含义是在内存停留的时间或者是在盘交换区停留的时间，一旦位置发生变化，p_time归零。

中断前是用户态才做这件事，说明只有在用户态下才对进程停留时间加一秒，如果中断前是核心态，是不加这个时间的。



**5、所有进程p_cpu=max(0, p_cpu-SCHMAG)**

<img src=".\assets\image-20241106222947090.png" alt="image-20241106222947090" style="zoom:50%;" />

以“调度魔数SCHMAG”拉低所有进程的p_cpu，直至0。

调度魔数就像一个阈值，一个进程，只有在过去一秒内，在台上执行的时间达到这个阈值，变化趋势才是增加的，直至为0。最低值为0。

p_cpu没有在某个时刻全部清零的这种操作，不需要，因为调度魔数这种机制，使得如果一个进程始终不上台，那在整秒p_cpu=max(0, p_cpu-SCHMAG)一次次发生后，该进程的p_cpu就会慢慢减小，最后变成0。



**6、重算部分进程的优先数/9.重算当前进程的优先数**

两个非常重要的计算进程优先数的时机。

**p_pri = min { 255, ( p_cpu / 16 + PUSER + p_nice ) }**

p_pri：值越小，进程的优先级越高。最大255

只有p_cpu一项是随着时间变化的，除以16是为了减小p_cpu变化对进程优先级的影响程度。

**PUSER：固定偏置常数  static const int PUSER = 100**

p_nice： 相对优先程度 允许用户通过系统调用设置：超级用户-128~20；普通用户0 ~20

16这个系数越大，p_cpu变化对进程优先级的影响程度就越小。

p_nice设置的较大，进程的p_pri就会较大，进程的优先级就会较低。

<img src=".\assets\image-20241106223542514.png" alt="image-20241106223542514" style="zoom:50%;" />

<img src=".\assets\image-20241106223608246.png" alt="image-20241106223608246" style="zoom:80%;" />

p_cpu的变量修改方式，使得连续占用处理机较长时间的进程优先级下降；使得较长时间内未使用处理机的进程和虽然频繁使用处理机，但每次时间很短的进程优先级上升。反映了UNIX**防止高者恒高，低者饥饿的调度思想**。

<img src=".\assets\image-20241106223624908.png" alt="image-20241106223624908" style="zoom:80%;" />



**7、如果RunIn被设置，唤醒0#进程**

RunIn大于0时的含义：内存中没有合适进程可以调出至盘交换区。

RunIn被设置的时候，就是无法进行进程图像换进换出的时候，所以在阻塞挂起进程，不让它去寻找是否有进程适合交换。而这个挂起进程，就是0#进程。因为在第四步对所有进程p_time++了，所以当前所有进程的时间状态都发生了改变，要去检查系统中的RunIn标志是否被设置，如果该标志被设置，则清除该标志，并且唤醒0#进程。0#进程将根据进程的当前状态来决定是否需要进行进程图像在内存和盘交换区之间的交换。



以下总结内容来自课本：

#### 时钟中断功能

1. 维护系统时钟
2. 计时，即处理proc结构和user结构中与时间有关的项
3. 完成每秒一次的系统维护工作，包括重新计算所有用户态进程的优先数，检查磁盘交换区中是否有就绪态进程需要进内存，以及其他与定时睡眠有关的唤醒操作等等。

#### 时钟中断的特点

1. 确保获得准确时间

   时钟中断涉及对许多重要时间量的维护，为了获取精确的时间，应做到不放过任何一次时钟中断。为此,在i386体系结构中,时钟中断的优先级最高。而在时钟中断处理程序中，每次必做的部分是对时间增量的累计，例如u_utime，u_stime，p_cpu及Time::lbolt 等。

2. 烦琐事务可适当延后

   对于其他各个与时间有关的事务处理，延时几个 ticks之后再处理也无碍大局，例如对系统时钟的调整，即便推迟几次也不过暂时造成几十毫秒的时钟误差，以后可以追补，不会造成累计误差。同时，这些事务处理往往都是比较耗时的，比如进程优先数的维护、唤醒睡眠进程等。为此，若中断发生时现运行进程在用户态运行，说明被中断的不是紧急事务，系统可以继续执行这些繁琐的维护工作。否则，时钟中断处理程序会立即返回，耗时的系统维护工作推迟至下次时钟中断。

3. 允许中断嵌套

   由于时钟的优先级最高，且时钟中断中包含了许多繁琐耗时的事务处理，如果在时钟中断的过程中，都不允许其他中断嵌套，则有可能会导致一些外设比较紧急的中断请求被延误。为此，时钟中断在处理过程中，处理机优先级会降至0。这样，其他的中断请求就可以进入。这与一般的中断处理中始终不改变处理机优先级的方式不同。例如，磁盘中断时，处理机优先级始终保持高位(等于磁盘的中断优先级)，不允许其他同级和较低级的中断请求嵌套。

4. 与其他外设中断的区别

   虽然时钟中断和系统中其他的外设中断均由8259A芯片转发，但是在理解上，时钟中断与其他外设中断有很大的不同。可以这么认为：

   （1）外设中断“借用”一小段现运行进程的时间，目的在于帮助其他进程完成 I/〇扫尾工作，外设发送中断处理请求可以解读为：“嗨，内核，打扰一下，一块新的数据已经准备好了，请尽早检查。OK后，我就可以执行新的I/O任务了”。**外设中断逻辑上的发起者是执行系统调用发起 I/〇操作的其他进程，与现运行进程没有必然的关联。**
   (2)系统安排时钟中断是为了引人心跳(Heart Beat)，这些有规律的脉冲信号可激活系统中的日常维护，更是对进程计时的唯一手段。后者是系统调度用户态进程的重要依据。**可以认为，时钟中断的发起者是内核，作为调度的依据，时钟中断总是与现运行进程相关。**

### UNIX异常处理

<img src=".\assets\image-20241107095040452.png" alt="image-20241107095040452" style="zoom:80%;" />

异常又叫陷入，是软件中断（软中断）

中断的中断号来自8259，但是异常的中断号是x86手册规定的（硬件），不是来自8259。异常的中断号是硬件规定好的，也就是中断描述表IDTR的顺序是规定好的，具体的异常入口程序、异常处理程序可以程序员写，然后放进IDTR表相应的位置。

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20241107100118302.png" alt="image-20241107100118302" style="zoom:80%;" />

与中断的主要区别：

1. 没有EOI（因为EOI是发给8259的，异常不是来自8259）

2. 没有例行调度（因为异常表明进程执行的应用程序出现了问题，必须暂停运行排查故障，因此，这里不再进行进程的切换调度而是由现运行进程首先完成故障处理。**解决异常的进程不能下台。**）

3. 中断隐指令形成的硬件现场（部分异常会产生出错码ErrorCode，对于会产生出错码的异常：会在硬件现场再压入一个ErrorCode，因此在恢复现场时，需要另外删除错误码所占用的栈空间(在宏leave()之后)；对于不会产生出错码的异常：核心栈的状态和中断时完全一样）

   所以讲到这里，之前说的所有在中断返回前下台的进程核心栈帧都一模一样的结论就不再成立了，因为部分异常会在硬件现场多一个出错码。

   <img src=".\assets\image-20241107100907971.png" alt="image-20241107100907971" style="zoom:50%;" />

<img src=".\assets\image-20241107102100738.png" alt="image-20241107102100738" style="zoom:50%;" />

如果异常前为核心态，说明是内核代码的bug被触发，系统缺少行之有效的积极处理方法。屏幕输出错误信息，进入死循环等待系统管理员干预。

如果异常前为用户态，异常处理程序将异常类型转换为信号。信号机制实质上是UNIX V6++提供的可以向进程发送信息的一种机制，这个信息被称为信号，是一个正整数n。n的值记录在信号接收进程的proc结构的p_sig中，（进程未接收到信号时，p_sig=0）。一个进程对不同信号的处理方式都记录在该进程的信号处理表：user结构的u_signal[NSIG]数组（每个进程最多可以接收15个不同的信号）中：

（1）u_signal[n]=0，说明进程对信号n的处理方式是终止本进程

（2）u_signal[n]=奇数，说明进程对信号n不做任何处理

（3）u_signal[n]=非0偶数，则u_signal[n]即为相应的信号处理程序的入口地址，返回用户态，执行信号处理函数，在这种情况下需要修改核心栈和用户栈的栈帧，见下图。

UNIX V6++提供给用户程序一个系统调用signal(n,func)，用户程序通过这个系统调用可以将func指向的对信号n的处理函数的入口地址写入u_signal[n]单元。

<img src=".\assets\image-20241107104423549.png" alt="image-20241107104423549" style="zoom:80%;" />

因为相应的信号处理程序是用户自编，那么该程序就必须在用户态下才能执行。所以进程执行完异常入口程序，返回用户态后，才能去执行信号处理程序。

所以要实现，执行完异常入口程序，返回用户态，首先要执行一段信号处理程序，再转去执行之前引发异常指令的下一条指令（中断是转去执行引发中断的那一条指令，而不是下一条）

把u_signal[p_sig]放进核心栈的EIP（因为现代机的CS只有后两位有用，偏移地址始终为0，所以只换EIP就行了是不是），把原来的EIP压入用户栈，把核心栈的ESP指向的地址改成用户栈新的栈顶（刚刚压入的EIP位置）

工作原理：从核心态返回用户态时，恢复硬件现场，EIP+CS使得指令指向了信号处理程序，ESP+SS使得栈帧指向用户栈栈顶，那么信号处理程序就可以在用户栈栈顶进行压栈了。当信号处理程序执行结束时，之前在用户栈压入的EIP，其实就相当于信号处理程序的返回地址（栈帧的四个组成部分之一的那个返回地址）部分，弹出，就转到了之前异常程序的位置。

## UNIX系统调用

<img src=".\assets\image-20241111100942763.png" alt="image-20241111100942763" style="zoom:50%;" />

<img src=".\assets\image-20241111101025536.png" alt="image-20241111101025536" style="zoom:80%;" />

中断号也是在这个表中，但中断号不是来自于8259，而是事先写好在代码里，汇编语言中就存在这个80

INT 0x80叫做系统调用指令。进程在用户态下执行时，无法直接调用系统调用子程序，因为系统调用子程序是内核程序 ，受系统保护，如果运行应用程序随意访问内核，计算机系统的安全性将无从谈起。所以，当进程执行应用程序需要操作系统服务时，必须使用的是系统调用指令。

对应系统调用的中断号只有一个0x80，只有一个中断入口，如果完成不同的系统功能？

<img src=".\assets\image-20241111101431547.png" alt="image-20241111101431547" style="zoom:80%;" />

系统调用子程序入口表中虽然有64项，但是UNIX V6++只使用了前49项，余下部分留待扩充。

用户态下的需求（系统调用号和参数）怎么送入核心态？

系统调用的结果怎么返回给用户进程？

**利用寄存器作为用户态和核心态之间传递信息的通道**

<img src=".\assets\image-20241111102048579.png" alt="image-20241111102048579" style="zoom:80%;" />

库函数的函数参数就是需要的参数，其中会有INT 0x80的代码，每个库函数中会有对应自己的系统调用号。都齐全了，存在寄存器中压入核心栈。核心态返回值放进寄存器随着栈被弹出而返回。

每个系统调用均唯一对应于一个高级语言用户库函数（**钩子函数**）。运行在用户态。

<img src=".\assets\image-20241111102501745.png" alt="image-20241111102501745" style="zoom:80%;" />

需要的东西就是以上4点，如果4点全部已知，就不用调库函数，直接写这条汇编语句。

下图中，是该位置等于-1，少写了一个负号

<img src=".\assets\image-20241111103005063.png" alt="image-20241111103005063" style="zoom:80%;" />

<img src=".\assets\image-20241111112513510.png" alt="image-20241111112513510" style="zoom:70%;" />

系统调用处理程序栈帧如上，然后会调用处理子程序，处理子程序不需要入口参数，因为在user结构的u.u_arg[5]

（1）软件现场

（2）转核心态

（3）系统调用处理程序(Trap)

3.1根据系统调用号查询系统调用处理子程序入口表，获得参数个数、系统调用处理子程序入口，将所需的参数由栈帧复制到user结构的u.u_arg[5]中

<img src=".\assets\image-20241111103341661.png" alt="image-20241111103341661" style="zoom:50%;" />

<img src=".\assets\image-20241111103612958.png" alt="image-20241111103612958" style="zoom:60%;" />

3.2执行系统调用处理子程序

功能虽不同，但遵循以下规则： 

1.参数取自user结构；

2.进程可能会因为使用系统资源而**入睡，下台，等待被唤醒后重新上台**； 

3.如果系统调用成功，返回值填入核心栈中保存EAX的位置； 

   如果系统调用失败，该位置=-1， 置系统调用出错码u_error（user结构中的）

:star2:使用外设阻塞就发生在系统调用，所以绝大部分系统调用都会去睡眠，只有极少数系统调用不睡。所以在系统调用中发生非抢占调度。**所有的睡眠进程都处在系统调用中，所以都在核心态。需求在用户态产生，睡在核心态**。

3.3重算**现运行进程**优先数

:star2:只有3个地方重算p_pri：时钟中断的6重算部分进程的优先数；时钟中断9重算当前进程的优先数；系统调用的3.3重算当前进程的优先数（注意，是重新用公式计算，不是改变，改变不止这三次）

（5）例行调度

中断前一定是用户态才会进系统调用，所以例行调度的一个条件“中断前是用户态”已经天然满足。

（6）恢复返回

64个子程序SystemCall::Sys_XXXX()组成的集合是**内核的系统调用接口**。是内核允许应用程序通过INT访问的（唯一）部分，**应用程序只有通过系统调用接口使用系统资源**。（取决于内核允许用户使用什么功能）

<img src=".\assets\image-20241111104740629.png" alt="image-20241111104740629" style="zoom:80%;" />

call指令实现不了系统调用，INT指令是借助中断隐指令，从用户栈进入核心栈。

<img src=".\assets\image-20241111110442487.png" alt="image-20241111110442487" style="zoom:80%;" />

两次swtch

1. 是使用外设导致的阻塞，主动下台，主动swtch，非抢占调度。

   下台之后，外设工作，进程在睡眠状态，睡多久取决于外设的速度 。直到工作完成当前台上进程会中断，唤醒阻塞进程，进程变成就绪状态，就绪多久取决于进程的优先级（刚被唤醒的进程，它的优先数是高睡或者低睡时赋予的优先数，小于100的数）和就绪进程的数量。

   那么，pa是核心态就绪进程，pb是执行进程，pa的优先数不是一定高于pb吗，pb不是一定下台吗？只是上台的不一定是pa？什么情况下不是pa？需要是还有其他核心态就绪的进程，就是说，pb是台上进程，先处理了pa的中断，此时pb处于核心态，然后此时又有一个进程pc提出了中断处理请求，如果发生中断嵌套，pc被唤醒，也去设置RunRun，但是因为中断嵌套不会触发检查RunRun和swtch的例行调度，所以虽然pc优先级最高，但此时无法上台，pb执行完pc的中断，返回核心态继续执行pa的中断处理，来到了返回用户态前的例行调度，RunRun是大于0的，触发swtch，pc是优先级最高的，所以就出现了上台的进程不是pa的情况。

   最近一次上台的机会：**pb返回用户态的例行调度中（如果优先级够高）**

   是合理的，因为如果pa上台执行的是核心态下的后半段系统调用，而pb要返回用户态，反映了**核心态优先级无条件高于用户态**的思想。

2. 是系统调用结束前的例行调度，后面会讲到，本次例行调度一定会下台。抢占调度。

   进程变就绪态，就绪多久取决于进程的优先级和就绪进程的数量。

   最近一次上台的机会：**本次例行调度中如果优先级够高，会被重新选中。**

   本次调度就可能上台，和中断不一样，中断时的例行调度如果RunRun>0，证明台上进程不是最优 ，swtch的结果一定是进程切换。但是系统调用的例行调度台上进程一定RunRun>0，但原因不是pa进程优先级不够，所以swtch可能发现pa就是优先级最高的，所以swtch一圈还是pa上台。

   也是合理的，因为系统调用已经完成，要回用户态了，所以这里就可以抢占了。

<img src=".\assets\image-20241111110402416.png" alt="image-20241111110402416" style="zoom:80%;" />

## UNIX的进程调度状态

### 成员函数

和**单个进程**的控制相关的操作作为**Process类的成员函数**

<img src=".\assets\image-20241112103349374.png" alt="image-20241112103349374" style="zoom:80%;" />

和**所有进程**的控制相关的操作作为**ProcessManager类的成员函数**

<img src=".\assets\image-20241112103435198.png" alt="image-20241112103435198" style="zoom:80%;" />

<img src=".\assets\image-20241112104317650.png" alt="image-20241112104317650" style="zoom:80%;" />

<img src=".\assets\image-20241112104528629.png" alt="image-20241112104528629" style="zoom: 50%;" /> 

<img src=".\assets\image-20241112104508784.png" alt="image-20241112104508784" style="zoom: 67%;" />

注意区分：p_stat是进程状态；p_flag是进程标志位，用于进程图像换进换出。

### 完整流程

用户态常规执行状态

<img src=".\assets\image-20241112105203559.png" alt="image-20241112105203559" style="zoom:40%;" />

CPU内的寄存器是该进程的执行现场，CR3寄存器指向的页表系统中登记着该进程的地址映射方式。即0x201号页框中的1023号PTE指向该进程的PPDA区，0x202和0x203号页框装载该进程的用户页表。

需要外设→执行系统调用→进程主动入睡

<img src=".\assets\image-20241112105231843.png" alt="image-20241112105231843" style="zoom:80%;" />

使用快速设备（一定会在有限时间恢复就绪）的处在高优先权睡眠状态，优先级更高，更快被唤醒。例如：磁盘操作

使用慢速设备（时间未知，甚至可能永久睡眠）的处在低优先权睡眠状态，优先级没那么高。例如：键盘、网络IO，用于进程通信的P操作和PIPE文件读写操作。

<img src=".\assets\image-20241112105248238.png" alt="image-20241112105248238" style="zoom:50%;" /> 非抢占调度的核心栈一定长这样，sleep修改，swtch下台。

进程被唤醒→swtch选中上台

进程被唤醒变成就绪态，但是p_pri不做修改，仍为睡眠设置的小于100的值。

<img src=".\assets\image-20241112105638318.png" alt="image-20241112105638318" style="zoom:80%;" />

swtch被选中上台之后，完成系统调用剩余代码，在完成trap之前，p_pri仍然未修改。

<img src=".\assets\image-20241112105743003.png" alt="image-20241112105743003" style="zoom:80%;" />

直到trap代码完成，在trap末尾重算现运行进程优先数。**是在回用户态前才换回大于100的优先数。**

然后例行调度→swtch下台

<img src=".\assets\image-20241112110033003.png" alt="image-20241112110033003" style="zoom:50%;" /><img src=".\assets\image-20241112110051309.png" alt="image-20241112110051309" style="zoom:80%;" />

抢占调度下台的进程核心栈一定长这样。

一个完整的进程从用户态进入系统调用，最终返回用户态的过程：

<img src=".\assets\image-20241112110248175.png" alt="image-20241112110248175" style="zoom:80%;" />

<img src=".\assets\image-20241112110300103.png" alt="image-20241112110300103" style="zoom: 80%;" />

那么对于唤醒pa的pb来说，他在台上，进入核心态处理中断，然后swcth被调度下台时，进入的就绪态就是左边那个。没有阻塞，只是执行变就绪，没有经历优先数设置成小于100的过程。

### 用户态就绪与核心态就绪

关于这两个就绪状态：

（1）这两个就绪状态有什么不同？

1：两个就绪状态的进程的核心栈不同

<img src=".\assets\image-20241112111738581.png" alt="image-20241112111738581" style="zoom: 67%;" />

2：两个就绪状态的进程再次上台后的任务不同

优先数小于100的就绪态上台完成核心态剩余代码（也因此上面的图核心栈帧更深），优先数大于100的就绪态上台后返回用户态执行。

3：两个就绪状态的进程优先数不同

优先数小于100的就绪态，优先级高，尽早上台完成核心态任务；优先数大于100的就绪态有较低的优先级，返回用户态。

<img src=".\assets\image-20241112112116317.png" alt="image-20241112112116317" style="zoom:80%;" />

起名：用户态就绪与核心态就绪

:star2:注意，核心态就绪和用户态就绪指的是它们重新上台后要做的事情所处的状态，而不是它们当前所处的状态（都在核心态）。核心态就绪是在系统调用中主动swcth下台，用户态就绪执行完中断例行调度时swtch下台，都处于核心态下。

:star2:**进程从执行态变就绪态，和从就绪态变执行态，都是在进程处于核心态时完成的。也就是一个进程如果处在就绪态，那么它一定是在核心态。**

所以之前讲的，时钟中断在整秒时重算部分进程的优先数，“部分”指的是所有用户态就绪的进程（p_pri>PUSER）。包括现运行进程，因为既然执行了秒数加1，证明现运行进程时钟中断前在用户态，所以优先数是大于100的。高睡、低睡、核心态就绪的进程都不计算，要让它们保持那个小于100的优先数，但是整秒时所有进程p_cpu=max(0, p_cpu-SCHMAG)这里的“所有”是真正的所有，高睡、低睡、核心态就绪的进程都要计算，为的是在这些进程未来返回用户态前重算优先数时是计算出来的是正确的p_pri。（相当于先用p_cpu存着，但不在p_pri中更新，等到正确时刻再更新）

（2）进程进入这两个就绪状态的原因有什么不同？

进入核心态就绪的原因是进程无法再执行下去，立即调用Swtch放弃处理机。

进入用户态就绪的原因是返回用户态前，进程可以执行下去，但是RunRun>0。

### RunRun修改的时机（部分）

这里指的是抢占式调度中，1秒计时到和现运行进程优先级下降的两种情况中RunRun修改的时机。RunRun修改的时机就是在setPri()中

后面会讲到抢占调度中更高优先级进程就绪的情况中RunRun修改的时机。RunRun修改的时机是在进程被唤醒的setRun()中

但是S21的课件更高优先级进程就绪为什么是列在抢占调度里面？非抢占调度不是也存在更高优先级进程就绪吗？被唤醒的进程一定是更高优先级进程啊。就是说，如何界定更高优先级进程就绪是抢占调度还是非抢占调度：首先，我为什么会之前觉得可以属于非抢占调度，是因为考虑了一种情况：pb处理pa的中断，然后pc也发出中断请求，中断嵌套，pb先处理完pc中断，不进行例行调度，再处理完pa的中断，例行调度，pc上台，我觉得pc上台而非pa上台就是更高优先级进程就绪，这是在非抢占调度中发生的。其实，非抢占调度指的是pa因为外设而主动sleep，主动swtch，这次进程切换叫做非抢占调度，pb上台 了。而后面的再pb中断返回前例行调度，pc上台，属于抢占调度。所以更高优先级进程就绪属于抢占调度。问题的关键在于，是否为抢占调度看的是下台原因，而不是上台原因，或者换句话说就是，**非抢占调度是直接调用swtch，抢占调度是看RunRun被设置才调用swtch**。除了按照是否抢占调度来分类以外，还可以有下面这种分类方式：

<img src=".\assets\image-20241123212741589.png" alt="image-20241123212741589" style="zoom:50%;" />

那么综合两种分类方式来看，可以说是：非抢占调度台上进程一定下台，抢占调度中如果原因是更高优先级进程就绪，台上进程一定下台；如果原因是一秒计时到或者现运行进程优先级下降，台上进程不一定下台，可能swtch的结果还是台上进程。（但台上进程中间也下台了，因为中间一棒是0号进程完成的）

还要注意一点，这里说的更高优先级进程就绪会让现运行进程无法在CPU上继续执行，指的是一定会被抢占，而不是进程本身不能继续执行下去。



之前说的三次重算优先数 ：

1. 整数秒，重算所有用户态就绪的进程的优先数
2. 整数秒，重算现运行进程的优先数
3.  系统调用末尾，重算现运行进程的优先数

“重算”指的就是调用setPri()函数对优先数用公式进行计算，注意是setPri()只有三次，改变不止三次，在进程入睡时调用的sleep也改变了优先数，变成了小于100的数值。

<img src=".\assets\image-20241112133601199.png" alt="image-20241112133601199" style="zoom:80%;" />

（1）对于3：系统调用末尾，重算现运行进程的优先数

Setpri有两个目的： 

1. 刷掉核心态下的优先级，恢复计算获得的优先数
2. 现运行进程优先级下降，设置 RunRun

这里就是之前说的：系统调用最后的例行调度一定会发生。

进行例行调度的两个条件中，首先，第一个条件已经满足，系统调用发生前一定是用户态；第二个条件是RunRun>0，之前说这一条也是一定满足的。原因就是在这里进行了Setpri，台上进程的优先数变成了一个大于100的值，而该进程本次上台是阻塞被唤醒之后选中上的台，上台的时候优先数是小于100的，所以一定满足“算得的优先数>现运行进程上台时的优先数”。也就是从小于100变成大于100，优先级明显下降，主动swtch。（主动的原因是：该进程上台是因为它是核心态就绪，优先数小于100，优先级天然高于用户态就绪的进程，所以它在阻塞被唤醒之后被选中上台了，而现在它执行完了系统调用，完成了核心态的工作，要返回用户态了，优先级明显下降，而这时如果台下来了更高优先级就绪的进程，它也没有权利执行swtch来让自己上台，所以需要台上进程主动swtch，而主动的方法就是设置RunRun，只要RunRun被设置了，就会执行swtch。所以RunRun只影响swtch是否执行，不影响实际的进程切换。台上进程虽然优先级降了，主动swtch，但是不一定下台：①虽然自己优先级降了，但依然是最高的，swtch一圈之后还是自己上台②真的有台下进程优先级更高，就进行进程切换。

（2）对于1：整数秒，重算所有用户态就绪的进程的优先数

这里的重算，既重算现运行进程，也重算其他所有的用户态就绪进程

可能发生的情况：

1. 如果现运行进程在台上的时间足够长，就会对现运行进程的重算满足：算得的优先数>PA上台时的优先数。所以是现运行进程优先级下降，设置RunRun。

2. 如果现运行进程在台上的时间不够长，就会对其它进程的重算满足：算得的优先数>PA上台时的优先数。所以是1秒时间到，设置RunRun。

因为这种设计，1秒到，一定会swtch。所以UNIX被称作分时系统。（其实这里的原理不用懂，写的也没有很清楚，就记住结论就好，就是基于setPri()函数，一定会在整秒时RunRun被设置而执行swtch）

<img src=".\assets\image-20241112142827230.png" alt="image-20241112142827230" style="zoom:80%;" />

（3）对于2：整数秒，重算现运行进程的优先数

<img src=".\assets\image-20241112143105427.png" alt="image-20241112143105427" style="zoom:50%;" />

是因为7和8可能花费较长时间，给现运行进程多一次重算优先数的机会。

<img src=".\assets\image-20241112143239146.png" alt="image-20241112143239146" style="zoom:80%;" />

解释了之前所讲，非抢占调度发生在阻塞或者终止，进程切换是台上进程主动sleep，主动swtch实现的。抢占调度发生在时间片轮转、更高优先级进程就绪、现运行进程优先级下降。中断结束前的例行调度是抢占调度的唯一时机，时钟中断或是系统调用返回前的例行调度，会setpri重算优先数，setpri里面包括RunRun的设置，导致了swtch，完成了抢占调度。

:star2:RunRun标志位被设置：现运行进程**可能（而不是一定）**已经不适合继续在CPU上执行了

:star2:对于pa，因为外设而系统调用，系统调用返回前的例行调度一定会发生。对于pb，是恰好在台上而被叫去帮pa处理中断，中断返回前的例行调度不一定会发生。

### 总结

<img src=".\assets\image-20241112145558224.png" alt="image-20241112145558224" style="zoom:80%;" />

新创建的进程预设优先数是0，会抢在所有用户态就绪进程之前获得上台机会，这是UNIX V6++给新进程的一个小特权。

如果新进程创建时，内存不够，就创建在盘交换区上，要等进入内存，才能参与swtch。

如果内存不足以容纳所有的进程图象，会进行与盘交换区的进程图像交换。

就绪进程图像可以换进换出内存，睡眠进程图像只可能换出内存，不可能换进内存（只有就绪进程才可能换进内存）。

2个调度方式：抢占调度、非抢占调度

6个调度状态：执行状态、新进程就绪状态、用户态就绪状态、核心态就绪状态、高优先权睡眠状态、低优先权睡眠状态

5个内核函数：sleep、swtch、wakeupall、newproc、sched

## UNIX进程调度控制

### 进程切换调度

#### 进程的睡眠与唤醒

##### Sleep

Sleep（chan，pri）chan是睡眠原因（一个内存地址），pri是优先数

<img src=".\assets\image-20241115144151233.png" alt="image-20241115144151233" style="zoom:50%;" />

所以非抢占调度的核心栈，swtch栈帧的返回地址：高睡return，低睡信号处理

<img src=".\assets\image-20241115144247386.png" alt="image-20241115144247386" style="zoom:60%;" />

##### WakeUpAll

唤醒函数是WakeUpAll，函数中是for循环，线性查询每一个进程，如果睡眠原因是当前chan，就执行setRun()去叫醒进程。唤醒的依据只是睡眠原因，没有去查看进程的状态是否为高睡或低睡。所以WakeUpAll的含义就是唤醒所有在此原因下睡眠的进程，所以是all，而实际的唤醒操作是setRun()做的，唤醒进程，不改优先数，让其核心态就绪。是一个设置RunRun的时机，如果被唤醒的进程优先级高于现运行进程（也就是唤醒它的进程），就设置RunRun。

setPri设置RunRun条件是算得的优先级高于现运行进程优先级；setRun设置RunRun条件是被唤醒进程的优先级高于现运行进程优先级

<img src=".\assets\image-20241115144443628.png" alt="image-20241115144443628" style="zoom:60%;" />

被唤醒进程拿着高睡或者低睡的一个小于100的优先数作为现在的优先级，如果这个优先级高于现运行进程，设置RunRun。对应的就是更高优先级进程就绪的情况。而这个RunRun的设置第一次使用到swtch中就是pb的中断返回，是pb的抢占调度，所以更高优先级进程就绪是抢占调度。

下面考虑一些情况：

（1）多个进程睡在原因chan上：

答案是全叫起来，不该醒的继续睡。

只有一个能抢到CPU，剩下的都抢不到，系统调用sleep(second)再次入睡。注意，睡眠原因不再是外设，而是Time::out（闹钟）

sleep(second)是系统调用，参数以秒为单位。second就是系统调用的参数传递，从软件现场EBX被存到user结构，放在u.u_arg[0]中。

Time::tout：闹钟：设置为距离当前时间最近的需要唤醒进程的时间点。

Time::time：当前系统时间。Time声明的static成员，在内核区。

系统调用的函数：

<img src=".\assets\image-20241115163657071.png" alt="image-20241115163657071" style="zoom:70%;" />

 wakeTime属于Sys_Sslep的局部变量，在进程核心栈的栈帧里。（系统调用栈帧的局部变量部分）

1.该醒的进程wakeTime == Time::time：上台后退出while循环，从Sys_Sslep返回； 

2.不该醒的进程wakeTime > Time::time：上台后，判断是否需要修改闹钟，然后再睡。

<img src=".\assets\image-20241115163849338.png" alt="image-20241115163849338" style="zoom:67%;" />

闹钟执行流程详细示例见S22课件15--22页

<img src=".\assets\image-20241115164038982.png" alt="image-20241115164038982" style="zoom:60%;" />

相当于是如果多个进程是因同一个原因入睡，所以同时被唤醒，一个进程抢到了CPU，剩下的进程通过执行系统调用继续入睡，就是睡在系统调用上。进入这个系统调用的时候先设置好自己需要被叫醒的时间，依据的就是参数传递过来的second。然后进入while循环，设置好闹钟以后调用sleep入睡，睡眠原因chan就是Time::out闹钟。时钟中断整秒时会检查当前时刻是否为系统中唯一的闹钟的时间，如果恰好是闹钟时间，就会唤醒所有定时睡眠进程。

###### 问题1

在这个系统调用的开始和结尾开关中断，目的是：

因为中断返回前是抢占调度的唯一时机，关掉中断可以避免抢占调度。是说，不允许在这些进程定时睡眠时，有其他进程来抢占CPU吗？一定要让这些指令先依次到达定时时间上台执行，不允许其他进程抢占？

注意：sleep(second)是系统调用，Sleep（chan，pri）是一个函数。所以是在进入定时睡眠的系统调用之后关中断，阻止其他进程在该进程定时睡眠时抢占CPU。那是每一个在此时需要定时睡眠的进程进入同一个系统调用吗？

（2）开关中断

<img src=".\assets\image-20241116223225689.png" alt="image-20241116223225689" style="zoom:50%;" />

进程pa因为外设而进入系统调用，如果这个外设是一个速度超快的设备，瞬间就绪，pa的系统调用执行sleep到p_wchan的位置，这时外设就绪，因为执行完sleep中的swtch（后面马上会讲，swtch的执行者不是pa，是0号进程）进程pa做第一棒交接给0号进程才会下台，所以在设置p_wchan=chan的时候，pa还是台上进程，所以pa转去处理中断，pa处理自己的中断，执行setRun，执行了p_wchan=0和p_stat=Process::SRUN。而setRun函数的返回地址是刚刚的sleep，又接着执行了p_stat = SSLEEP和p_pri = pri。最后pa中断返回。但是是以p_wchan=0且p_stat = SSLEEP的状态存在。wakeup唤醒的依据是睡眠原因p_wchan，进程切换调度的依据是进程当前状态p_stat。pa两边值不一致，既不会被唤醒，又不会上台执行。所以避免这种情况的发生，要在sleep的参数设置前后开关中断。

但是，pa是进了系统调用，是核心态，如果响应中断就是中断嵌套，需要满足优先级大于系统调用的优先级的吧，如果不大于，难道系统就死掉了？而且系统调用的中断号是0x80，非常高。

感觉思路就错了，响应中断指的是PA请求外设，外设准备好的时候，当前台上进程PB响应中断。所以系统调用和这个是没有关系的，只是PA以核心态去响应中断而已，不存在中断嵌套。

<img src=".\assets\image-20241116224144255.png" alt="image-20241116224144255" style="zoom:50%;" />

而这里被SetRun的进程不是现运行进程（刚刚是因为恰好还没能入睡，现在的已经在睡了），没有上台执行， 不可能发生几个参数不一致的情况。

#### 进程的下台与上台

（1）保存现场

存的是核心栈的ebp和esp。之前说对于所有在中断返回前下台的进程，核心栈都长得一模一样，就是下图。因为中断返回前下台的前提是中断前处于用户态，那么进入核心栈时就是空的。而对于每个中断会不同的中断处理程序这时已经撤销，所以核心栈一模一样，都是下图。

<img src=".\assets\image-20241027114935413.png" alt="image-20241027114935413" style="zoom:33%;" />

但是讲到现在，这个观点已经不成立了，因为部分异常会产生出错码。

<img src=".\assets\image-20241107100907971.png" alt="image-20241107100907971" style="zoom:50%;" />

之前说的是“中断返回时下台”，指的是pb在台上时响应pa的中断处理请求，然后pb在中断返回时下台。现在可以知道，除了这种抢占式下台，还有pa主动入睡时的非抢占下台。两种栈帧不同。（哦，在这里还可以发现，对于pa来说，两次下台是第一次非抢占，第二次抢占。对于pa在“第一次下台后swcth选中上台”时，谁能够上台是抢占调度（这里也就解释了为什么更高优先级就绪是抢占调度）。还是那个观点，中断返回前的例行调度是唯一的抢占时机，pb的中断返回前例行调度是它处理完pa的中断请求准备返回，是pa在“第一次下台后swcth选中上台”时是pb的抢占调度。pa的中断返回前例行调度是系统调用返回前，是pa在“第二次下台后swcth选中上台”时是pa的抢占调度。）

抢占式调度的下台进程核心栈的esp和ebp不是所有进程都相同，因为有些异常会有出错码。

非抢占调度下台的进程核心栈的esp和ebp不同，因为下图左图所示，省略号位置是调用外设的栈帧，每个进程是不同的。

###### 问题2

（但之前那句所有在中断返回前下台的进程核心栈esp和ebp都相等除了部分异常有出错码还是成立的吧，因为这个非抢占是发生在系统调用的前半段，不是中断返回前）

<img src=".\assets\image-20241116231222691.png" alt="image-20241116231222691" style="zoom:50%;" />

（2）选新进程

select()函数

<img src=".\assets\image-20241116233104700.png" alt="image-20241116233104700" style="zoom:50%;" />

从**上次**查找到的进程位置开始线性循环扫描 process数组，找**图像在内存**的**优先级最高**的**就绪**进程。

注意观察这个代码，i会被设置成现运行进程的下一个位置， priority初值会设置成256（最大优先数，最小优先级）。如果现运行进程的下一个位置优先数小于256，best就会设置成了现运行进程的下一个进程。而且比较是小于号不是小于等于号，所以如果后面的其他进程优先数和现运行进程的下一个进程只是并列，best是不会切换的。因此如果系统中所有就绪进程都是并列优先级，则会一秒切换一个进程，轮流执行（因为整秒重算用户态就绪进程优先数用的setPri()就会导致整秒一定会设置RunRun而执行swtch）

就绪和执行设置成同一个状态SRUN，才能在swtch选择新进程时处于同等的选择地位。现运行进程如果想要在select之后还在台上，需要做到它是唯一最高者，才能转一圈回到现运行进程是best。

<img src=".\assets\image-20241116233254643.png" alt="image-20241116233254643" style="zoom:50%;" />

如果系统中没有就绪进程，执行hlt指令等待中断，中断返回之后select就会找到刚唤醒的进程。

那么选新进程的工作谁来完成？答案是0#进程。不是下台的进程执行的，只有0#进程有执行的权利。

之前讲到：

恢复现场的实际步骤是：先为新进程建立核心态页表（只刷新768号页表的最后一项PPDA的paddr，**只做这一件事**）；再恢复u_rsav[2]数组中的esp和ebp；最后为新进程建立用户态页表（用相对表去刷新0号和1号页表）

<img src=".\assets\image-20241026122722193.png" alt="image-20241026122722193" style="zoom:80%;" />

所以现在

<img src=".\assets\image-20241116234459115.png" alt="image-20241116234459115" style="zoom:50%;" />

本来恢复现场是先换核心页表，再换esp和ebp，最后换用户页表。但是因为0号进程只需要做swtch，是核心态下的事情，不涉及到用户态（0号进程根本就没有用户态），所以没有最后换用户页表这一步。

swtch选中的进程和栈帧和之前由于调用swtch而下台的栈帧是完全一样的（此处的一样指的是swtch栈帧相同，不是整个核心栈相同）。swtch程序使得一个进程放弃处理机时的工作环境和后来再度占用处理机时的工作环境完全相同，如果忽略两次调度之间的时间间隔，那么造成的效果和一个进程连续占用一台处理机一样。

第二次交接时恢复现场的esp和ebp，以及恢复现场完成，swctch撤销后进程指向的位置。抢占调度是回到CLI关中断，非抢占调度是回到sleep的最后，如果是高睡就是return，如果是低睡就是信号处理。

<img src=".\assets\image-20241116235552479.png" alt="image-20241116235552479" style="zoom:50%;" />

交接棒的过程中，只改变了201#页框的最后一个PTE，也就是PPDA区实际指向的物理地址。而x_caddr没变（因为在0号和1号用户页表当中），所以执行的一直都是同一段代码。

<img src=".\assets\image-20241117113631215.png" alt="image-20241117113631215" style="zoom:67%;" />



<img src=".\assets\image-20241117114613497.png" alt="image-20241117114613497" style="zoom:67%;" />

<img src=".\assets\image-20241117114628086.png" alt="image-20241117114628086" style="zoom:67%;" />

现运行进程入睡和终止不满足就绪状态，更高优先级进程就绪不满足唯一最高优先级，所以现运行进程一定会在swtch中下台。而现运行进程优先级下降和1秒计时到现运行进程仍然满足select选择条件，所以可能swtch中再次上台。

问：为什么要0号进程来做中间一棒？不能让原进程去做吗？

三棒是否可能是同一个进程？

这两个问题在本章最后0号进程的工作汇总中都回答了

进程在swtch中下台时，是做第三棒；在进程中上台时，是做第一棒。

<img src=".\assets\image-20241117232328827.png" alt="image-20241117232328827" style="zoom:80%;" />

#### UNIX动态优先权调度算法

1. p_cpu
2. p_pri
3. RunRun
4. swtch

<img src=".\assets\image-20241117183821150.png" alt="image-20241117183821150" style="zoom:67%;" />

更高优先级就绪、一秒计时到和现运行进程优先级下降是三个抢占原因，不会立即调用swtch，会在中断/系统调用返回前swtch（抢占调度是通过设置RunRun来调用swtch）

进程入睡/终止是两个非抢占调度原因，会立即调用swtch。是返回用户态前，进程可以执行下去，但是RunRun大于0。

##### RunRun的修改时机

RunRun在计算优先数函数setPri()和唤醒睡眠进程函数setRun()中被设置

RunRun被设置会导致例行调度，叫做强迫调度（与入睡/终止主动放弃形成对比）

因为整秒时的时钟中断是固定发生的，所以强迫调度发生很频繁，一秒内至少设置一次。

（1）setPri()

1. 整数秒，重算所有用户态就绪的进程的优先数

   一秒到，RunRun一定被设置

2. 整数秒，重算现运行进程的优先数

   因为耗时的事务处理，再给现运行进程一次计算机会。RunRun不一定被设置，只有在现运行进程占用CPU时间确实很长时才会被设置

3. 系统调用末尾，重算现运行进程的优先数

   此处RunRun一定被设置：

   如果系统调用中进程未入睡，会因为长期占用CPU而RunRun被设置

   如果系统调用中进程入睡，会因为自身优先级下降而RunRun被设置

（2）setRun()

1. 如果更高优先级进程就绪，设置RunRun

   RunRun在此处不一定被设置，一般是高睡/低睡被唤醒会设置

##### 优先数的变化时机

优先数改变的原因有设置和计算两种：

（1）设置睡眠进程的优先数

在高睡/低睡时设置（唤醒后不参与重算优先数，核心态就绪，易上台（因为核心态工作还没完成），在系统调用末尾优先数重算，就是下面的计算优先数（核心态事情做完了要回用户态了））

（2）计算进程的优先数

三个重算时机（见上述RunRun修改时机）

##### 进程切换调度的时机

（1）强迫调度标志RunRun被设置

见上述RunRun修改时机

（2）现运行进程暂时/永远无法继续执行

1. 进程入睡/终止

   主动swtch（立即，而强迫调度是要等到系统调用返回前swtch）

2. 现运行进程扩充图像时，主存空间不够

   进程的可交换部分被系统暂存在磁盘上，在图像被搬回内存之前，进程无法继续运行。

### 进程创建与终止

#### 进程创建

##### 创建过程

创建子进程的关键：为子进程构造一个能正确上台的图像

Newproc()步骤：

找一空闲proc[i]  复制p_textp

调用父进程的Process::Clone函数，为子进程的process结构赋值。

<img src=".\assets\image-20241120160647900.png" alt="image-20241120160647900" style="zoom:50%;" />

这里的x_ccount+1是没有考虑子进程创建时就在盘交换区的情况

<img src=".\assets\image-20241120160719007.png" alt="image-20241120160719007" style="zoom:50%;" />

虚实地址映射表是一模一样的。对于四张页表，p_addr相关部分都不同，p_textp相关部分都相同。201号页框的前1023项相同

父进程在为子进程创建虚实表时，父进程首先将自己的两张相对地址映射表的地址备份到pgTable中，为的是将来恢复自己的相对地址映射表。进而重新申请两张空白的相对地址映射表，并使自己的User对象中的u_MemoryDescriptor.m_UserPageTableArray指针指向空白虚实表的起始地址。这样做是为了图像复制时把这个地址值直接复制给子进程。

<img src=".\assets\image-20241120160751747.png" alt="image-20241120160751747" style="zoom:50%;" />

子进程得到了一张和父进程基本一样的图像（代码段和进程可交换部分的内容完全一样，p_textp相同，p_addr不同）

<img src=".\assets\image-20241120162819417.png" alt="image-20241120162819417" style="zoom:80%;" />

在完成1、2后，要 esp, ebp-> u.u_rsav目的在于：把esp和ebp放进了user结构中，这样在复制进程图像给子进程时，子进程的u.u_rsav里面就装着esp和ebp，对应着newproc栈帧。因为子进程之前没有上过台，所以没有经历“保存现场“，但它未来第一次上场时需要”恢复现场“，所以需要手动把esp和ebp存进去。

为了实现复制进程图像，父进程的u_procp指向子进程的proc表，因此子进程现在暂时变成了现运行进程（仅有一个process结构，并不占用任何存储区）。执行完这一步，再去检查内存分配是否成功，如果成功，复制进程图像，子进程的p_addr指向该内存的起始地址。恢复父进程为现运行进程（父进程的u_prop指向父进程，父进程的u_MemoryDescriptor.m_UserPageTableArray利用地址备份pgTable指向自己的虚实表）。

至此，父进程执行完newproc，返回值为0，撤销newproc栈帧。

<img src=".\assets\image-20241120163556336.png" alt="image-20241120163556336" style="zoom:80%;" />

子进程创建时的状态是SRUN，因为父进程想要创建子进程的前提是它正在执行态，所以复制给子进程的状态是执行/就绪态。

<img src=".\assets\image-20241120163951731.png" alt="image-20241120163951731" style="zoom:80%;" />

从未上过台的子进程的核心栈与抢占调度/非抢占调度下台的进程核心栈都不同，它们的栈顶是swtch栈帧，而子进程的栈顶是newproc栈帧。子进程未来的第一次上台是在某次swtch被选中，用手动复制的指向newproc栈帧的esp和ebp恢复现场，swtch的返回值是1

###### 问题3

那子进程在swtch return1之后去了哪里？是去到newproc吗？那为什么子进程不会因为执行newproc而导致返回值也为0吗？

子进程得到了一张和父进程基本一样的图像。

如何让父子进程完成不同的工作？

进程创建利用的是fork()系统调用（2号系统调用），前面讲的newproc是fork()系统调用中的一部分，是return前的最后一部分。

<img src=".\assets\image-20241120174732490.png" alt="image-20241120174732490" style="zoom:50%;" />

newproc()的返回值，子进程是1，父进程是0。会进入不同的分支。分支中的操作就是设置fork()的返回值。子进程的话会把fork()返回值设置成0，父进程的话会把fork()的返回值设置成创建的子进程的id号。

所以，fork系统调用的结果，父进程返回创建的子进程的ID，子进程返回0

注意，系统调用的返回值是放在EAX（u.u_ar0指向EAX）里面被带回用户态的，返回值的设置方法不仅仅局限于return。是return 1转成汇编语句会把1放进EAX。直接把值放进EAX有同等功效。

<img src=".\assets\image-20241120222452030.png" alt="image-20241120222452030" style="zoom:80%;" />

fork()系统调用返回前的例行调度，如果父进程满足：

<img src=".\assets\image-20241120222605547.png" alt="image-20241120222605547" style="zoom:50%;" />

会导致RunRun>0，父进程p_pri>=100，而刚创建的子进程 p_pri =0，子进程抢占上台。

子进程在swtch中上台，在fork()系统调用返回前的SetPri()重算优先数，p_pri>=100， RunRun被设置，执行例行调度，父子进程都可能上台。

所以，父子进程都可能先返回用户态，分为两种情况：

①父进程满足三个条件之一，例行调度下台，在子进程重算优先数之后，父子谁先上台返回用户态不一定；

②如果父进程不满足三个条件中的任何一个，父进程不会下台，就是父进程先返回用户态。子进程会以优先数为0等待swtch中上台的机会。

##### 父子进程执行程序

（1）父子进程执行同一个应用程序

<img src=".\assets\image-20241120223307987.png" alt="image-20241120223307987" style="zoom:80%;" />

在UNIX V6++中，两种情况都可能发生。

<img src=".\assets\image-20241120223348256.png" alt="image-20241120223348256" style="zoom:80%;" />

注意，a=0是main栈帧中的局部变量区，父进程和子进程的进程图像物理地址是不同的，是分开的，所以两个进程分别开始执行时，a的初值都是0。

（2）让子进程执行另一个应用程序

<img src=".\assets\image-20241120223910470.png" alt="image-20241120223910470" style="zoom:50%;" />

子进程改换进程图象，用磁盘上的可交换文件重新建一个全新的图像。父进程的进程图像只是用于子进程第一次利用swtch上台。

##### UNIX的进程树

<img src=".\assets\image-20241121095739842.png" alt="image-20241121095739842" style="zoom:30%;" />

只有0号进程不是fork出来的，是系统初启时在台上执行的进程。1号进程是0号进程的助手，是实际的管理者，从2号开始创建子进程。1号进程是所有终端监控进程的父进程，然后1号进程为每个终端生成一个子进程，子进程的数量与终端数量相等，就是shell进程。shell进程执行shell程序，shell程序是UNIX系统中的命令解释程序。shell程序所做的最主要工作就是解析命令行，为用户提供执行应用程序服务的。在此过程中，每个shell进程又可能创建若干子进程，每个子进程也可以按需再创建子进程。以此类推，UNIX系统中的进程构成了树形结构的进程族。除了同时存在的进程数受到限制外，树形结构的层次可以不断延伸。

#### 进程终止

子进程创建后可能先返回用户态，故有不确定性

如何确保子进程先终止？ 尝试1：让父进程定时睡眠

<img src=".\assets\image-20241121101303831.png" alt="image-20241121101303831" style="zoom:50%;" />

现在能保证子进程先终止了吗，在负载重的系统中仍然没法保证。如果是子进程先上台，正好满足；如果是父进程先上台，定时睡眠swtch中子进程不一定能上台，不知道定时睡眠要设置多久才够。

<img src=".\assets\image-20241121102443574.png" alt="image-20241121102443574" style="zoom:80%;" />

exit()是进程终止的系统调用。让父进程wait()，同步机制，睡在子进程的newproc上，子进程的exit()会唤醒睡在子进程上的父进程。这样执行顺序就是固定的了。父进程的wait()返回值是子进程的ID号。

<img src=".\assets\image-20241121102657716.png" alt="image-20241121102657716" style="zoom:80%;" />

wait()和exit()都是带一个参数的，这个参数是子进程返回给父进程的Return Code注意，wait()的参数是地址&。带&地址运算符，j才能把子进程的终止码带回来。

##### exit

<img src=".\assets\image-20241121103425693.png" alt="image-20241121103425693" style="zoom:50%;" />

所以子进程在调用exit()时，把它自己的Return Code会放在EBX里，然后存到u.u_arg[0]里面，u.u_arg是user结构中的，按照下图，子进程不会删除user结构，user结构被暂存在盘交换区上等待父进程的处理，所以这个Return Code被存在了盘交换区。

<img src=".\assets\image-20241120215230429.png" alt="image-20241120215230429" style="zoom:80%;" />

更改：把右侧的查找父进程成功的箭头指向“唤醒父进程”

一个进程的exit()终止过程中，会把它所有的子进程父亲改为1号进程。那么既然做了这个操作为什么还会出现“子进程查找父进程找不到”的情况？因为系统中的进程不是全部都正常结束的，在进程异常终止时是没有机会执行exit()的。所以查找父进程的这一步骤是一个保险操作。

##### wait

父进程检查是否有终止的子进程的依据是进程状态Process::SZOMB，是子进程在exit中设置的终止的中间状态。子进程的ID号放进EAX就是会作为wait系统调用的返回值。

如果没有终止的子进程：如果没有子进程，证明此时根本不应该wait，出错返回，退出wait；如果有子进程（如果去查找子进程：线性查找，依次查看每个进程的ppid是否等于自己的ID号，如果相等证明是自己的儿子。父进程每次只找到第一个儿子，也就是说1次wait只能等待1个子进程），父进程就睡在子进程上，Sleep(指向该子进程proc结构的指针, PWIT)。子进程叫醒的一定是等待子进程的父进程，如果父进程睡在其他原因上，子进程是叫不醒的。

<img src=".\assets\image-20241121103821458.png" alt="image-20241121103821458" style="zoom:80%;" />

将暂存在盘交换区上的子进程user结构读入一内存缓存，释放相应盘交换区，获取子进程exit(int status)的终止码。这时就获得了子进程的Return Code

<img src=".\assets\image-20241121104256799.png" alt="image-20241121104256799" style="zoom:42%;" />

<img src=".\assets\image-20241121103441293.png" alt="image-20241121103441293" style="zoom:50%;" />

把子进程的Return Code存在了父进程status地址所指的内存单元。

##### 回收PCB

UNIX V6++中并存的进程数量不能超过100，因此尽快回收终止进程的process块是非常必要的，否则系统将会因缺乏process结构无法创建新的子进程

系统最早何时能回收进程的process块，必须等到其父进程将process块中的信息采集完毕，或者系统确认终止进程PCB中包含的信息已无进程需要，所以是父进程在wait中回收。如果父进程在创建子进程后不执行wait系统调用，而是自顾自的运行，那么子进程终止后PCB的回收是一个大问题。（因为PCB中包含父进程需要采集的信息，系统丧失了回收子进程PCB的主动权）

1.如果父进程已经不存在，UNIX将指认1#进程为当前进程的父进程，由1#进程负责回收进程的PCB

2.如果父进程仍然存在，子进程回收操作将延迟至父进程终止之后，由1#进程回收。这将是一段无法控制的时间，是我们不愿意看到的。所以设计子进程终止信号SIGCHLD，子进程终止后，父进程会收到此信号，由父进程来回收子进程的PCB。

### 进程图像交换

<img src=".\assets\image-20241123133856783.png" alt="image-20241123133856783" style="zoom:50%;" />

进程图像交换的实现函数是swap，根据flag参数的值在内存和盘交换区之间交换进程图像，flag  = Buf::B_WRITE是写到盘交换区， flag  = Buf::B_READ是从盘交换区写到内存

swap中包含sleep，启动IO操作之后进程入睡等待， IO结束后中断处理中进程被唤醒

#### 内存空间不足时的图像交换

##### 进程图像的换入Sched

0# 进程执行ProcessManager::Sched

每秒时钟中断：对所有进程 p_time ++  根据p_time 从长到短调入内存

<img src=".\assets\image-20241123134539913.png" alt="image-20241123134539913" style="zoom:67%;" />

（1）找盘交换区上的就绪进程

代码段副本和可交换部分在盘交换区上是分开存储的，如果代码段需要进内存， size = 代码段长度p_textp->x_size + 可交换部分长度p_size，释放盘交换区上进程图像可交换部分所占空间空间，代码段副本始终在盘交换区上

<img src=".\assets\image-20241123135246833.png" alt="image-20241123135246833" style="zoom:50%;" />

sched()是一个循环程序，0号进程会一直在做，假设内存足够大，0号会一直执行进程图像调入直至没有就绪进程。当没有就绪进程在盘交换区上，无进程可调入 RunOut++; Sleep(&RunOut,-100)睡在RunRun上

**RunOut：盘交换区中无进程可以调入内存**

那么在RunOut上睡觉的0号进程，什么时候会醒来呢？

<img src=".\assets\image-20241123155241861.png" alt="image-20241123155241861" style="zoom:80%;" />

-100是最小优先数，最高优先级，所以有盘交换区上进程就绪时，唤醒0号进程（这里是中断嵌套，本来在setRun()这个盘交换区进程，现在去setRun()0号进程，0号进程优先级最高，下一次swtch时，一定是0号进程上台。

**只有0号进程因为RunIn和RunOut而睡眠时，才会永远最高优先级-100**

（2）内存是否有空余位置

如果没有内存空闲区时，从p_flag标志字不包含SSYS和SLOCK的进程中选择进程图象调出（SYS是不允许被换出，SLOCK是暂时不允许被换出（已经被选中正在换了））

##### 内存中图像的换出XSwap

注意，内存图像换出的前提是磁盘中有就绪进程需要进内存。因此，只要内存能容纳所有的进程图像，0号进程绝不会将任何进程搬出主存，哪怕这个进程处于低睡状态。

SSYS：系统进程图像，不允许被换出（只有0号进程拥有该标志）

<img src=".\assets\image-20241123160455062.png" alt="image-20241123160455062" style="zoom:80%;" />

优先调出低睡进程SWAIT

对高睡进程SSLEEP和就绪进程SRUN需调入者p_time>3，调出者p_time>2（单位是秒）

制定该规则的原理是：高睡本来应该快速醒来，p_time>2了还没醒，可能是出现了问题；就绪都p_time>2了还没抢到上台机会，说明不够紧急；而盘交换区上的进程已经p_time>3了，则互换。

<img src=".\assets\image-20241123161551313.png" alt="image-20241123161551313" style="zoom:50%;" />

bFreeMemory是否释放进程图像占用的内存。如果是因为盘交换区有就绪进程想要进入内存而有内存中进程调出时，是真正的调出，bFreeMemory是true。如果是父进程创建子进程时内存不够，其实是借用了XSwap来为子进程在盘交换区复制了一份进程图像，不是真正的调出，内存中的进程图像不释放，给父进程用，盘交换区的给子进程用

<img src=".\assets\image-20241123161650215.png" alt="image-20241123161650215" style="zoom:80%;" />

如果是内存中唯一一个使用该代码段的进程，就把代码段的内存空间释放，不需要换出代码段，因为盘交换区始终有代码段的副本

Process::SLOCK相当于是用一个状态给正在换出的图像上锁。处于这个SLOCK状态的进程，SLOCK：含有该标志的进程图像暂不允许换出，防止同一进程图像被重复换出（因为换出过程会睡觉，该进程是一个满足可换出条件的进程，如果不锁可能睡时再被找到换出，系统就出问题了）

绿色框：清除RunOut标志唤醒0号进程

如果无进程可调出时， RunIn++; Sleep(& RunIn,-100);（这时的0号进程，是有事可做的，在内存中找进程换出的前提一定是盘交换区上有就绪进程想要换入，有事可做但是做不了，内存没有合适进程可以换出）

**RunIn：内存中无合适进程可以调出至盘交换区**

睡在RunIn上的0号进程什么时候醒过来？

（1）有了低睡进程

0#正因为找不到可以换出的进程而睡觉。此时有进程进入低睡状态， 则唤醒0#进程将其换出

<img src=".\assets\image-20241123164838123.png" alt="image-20241123164838123" style="zoom:50%;" />

注意，这里只有低睡才检查RunIn，因为低睡可以直接满足进程图像换出，而高睡需要p_time也满足可换出，所以高睡的RunIn放在时钟中断的整秒事务处理中去写，就是下面的（2）。这里只写低睡。

（2）高睡和就绪进程p_time满足了条件

0#正因为找不到可以换出的进程而睡觉。此时系统时间又过去1秒，所有进程的p_time++,则唤醒0#进程查看是否可以换出

<img src=".\assets\image-20241123164949688.png" alt="image-20241123164949688" style="zoom:50%;" />

0号进程只要在台上就在sched()。从系统初启时就在sched()，如果有换进换出，0号进程被唤醒，否则睡在RunIn或者RunOut

#### 内存空间不足时的新进程创建

<img src=".\assets\image-20241123172746858.png" alt="image-20241123172746858" style="zoom:80%;" />

SIDL是进程状态，不是进程标志位。是进程创建时的中间状态 。

![image-20241123210807882](.\assets\image-20241123210807882.png)

设置成SIDL就不参与cpu调度，swtch不选。是为了在父进程把图像搬到盘交换区的过程中避免图像更改。

<img src=".\assets\image-20241123172406976.png" alt="image-20241123172406976" style="zoom:67%;" />

其实是借用了XSwap来为子进程在盘交换区复制了一份进程图像，不是真正的调出，内存中的进程图像不释放，给父进程用，盘交换区的给子进程用

进程创建，esp, ebp-> u.u_rsav； esp, ebp->u.u_ssav存了两次

<img src=".\assets\image-20241123171833913.png" alt="image-20241123171833913" style="zoom:60%;" />

原因是父进程创建子进程过程中如果内存不足，需要创建到盘交换区上去，这时父进程会入睡，会主动swtch，而swtch的保护现场会esp, ebp->  u.u_rsav。所以如果之前只存一次只存到u.u_rsav，在保护现场时就会被覆盖掉，所以要在u.u_ssav再存一份，来保证**Newproc栈帧的位置不会被覆盖**

<img src=".\assets\image-20241123172106694.png" alt="image-20241123172106694" style="zoom:60%;" />

<img src=".\assets\image-20241123172157537.png" alt="image-20241123172157537" style="zoom:50%;" />

等到在盘交换区上创建的子进程，后续会被调入内存，某一次Swtch中会被选中，在盘交换区上创建的进程第一次通过swtch上台时，新进程有SSWAP标志，用u_ssav[2]数组再次恢复esp和ebp，这样栈帧就回到了newproc（因为swtch栈帧撤销后不能再跑到sleep和外设、Xswap栈帧去执行，这些都是父进程系统调用时的栈帧）

<img src=".\assets\image-20241123173718144.png" alt="image-20241123173718144" style="zoom:80%;" />

SSWAP是进程创建之初就在盘交换区上，如果有此标志，证明是新创建，从未上台，刚从磁盘移到内存的进程

#### 当内存空间不足以让进程扩展自己的图像

<img src=".\assets\image-20241123185459203.png" alt="image-20241123185459203" style="zoom:80%;" />

这里为什么要进行类似新进程创建在盘交换区时的二次现场保护处理？

一共讲了三种进程图像到盘交换区的情况：

1.把内存中的低睡、高睡、就绪进程图像换出到盘交换区，只需要在换的过程中把p_flag改成SLOCK，在换完把SLOAD删除

2.子进程创建时图像在盘交换区上，父进程把子进程的图像复制一份到盘交换区这个过程中会入睡，所以核心栈在newproc栈帧上又会放很多系统调用、外设、sleep和swtch的栈帧。而子进程后续进入内存，因swtch而上台时，希望swtch栈帧撤销后就到了newproc位置，所以要存父进程在newproc栈帧时的esp和ebp

3.再看现在的现运行进程扩充空间时因内存不足而导致进程图像复制到盘交换区去，相当于成为了一个在盘交换区上的就绪进程，那么和2一个道理，复制到盘交换区的过程中也需要入睡，核心栈帧也会加深，而在从盘交换区回到内存swtch再次上台时，希望位置是在“p_addr指向新内存区的起始地址）

现运行进程图像需要扩充但内存空间不足时，会进程切换，在现运行进程swtch之前要先存到u_ssav[2]中，然后swtch中会存到u_rsav[2]中

<img src=".\assets\image-20241123190310906.png" alt="image-20241123190310906" style="zoom:80%;" />

<img src=".\assets\image-20241123190502626.png" alt="image-20241123190502626" style="zoom:80%;" />

栈扩展是缺页异常引发的，进程 不需要执行显式的系统调用。就是说栈扩展是一种异常，而不是一种系统调用。

#### 关于0#进程

0号进程就绪→下一次swtch就上台，执行schde()

睡眠→做swtch的中间一棒

是唯一一个在睡眠状态下在台上执行的进程



流程举例：

0号进程因为没有就绪进程而在RunOut上入睡，主动sleep调用swtch，睡眠中的0号进程select的新进程，选择一个进程上台执行。第一棒和第二棒相同。

出现设备中断，台上的现运行进程唤醒了一个磁盘进程，将磁盘进程唤醒时setRun会嵌套，去唤醒0号进程，0号进程醒的时候RunRun被设置；中断返回前例行调度，就绪态的0号进程选择新进程，选中的新进程就是0号进程自己。第二棒和第三棒相同。

0号进程因为没有就绪进程而在RunOut上入睡，主动sleep调用swtch，睡眠中的0号进程select的新进程，如果这时没有就绪进程，0号进程等待中断；中断中如果恰好唤醒一个磁盘进程，则0号进程被同时唤醒，wakeupall的系统调用是唤醒磁盘进程中断的中断嵌套，不调度，执行结束回到上一级中断，中断返回前因为0号进程的setRun设置了RunRun，所以会swtch，0号进程上台(0号进程刚开始做第二棒的时候是睡眠的，等待中断的过程中因为wakeupall(RunOut)而自身从睡眠变成就绪，等待继续select的时候就是以就绪状态在做第二棒了，并且因为0号进程的优先数是-100，它选择的第三棒还是自己)返回到了0号进程的schde()中，等到了中断，选新进程，一个磁盘进程被唤醒，一个优先数处于-100的0号进程被唤醒，所以新进程恰好是0号进程自己。三棒都相同。



对于睡眠时担任swtch的中间一棒：睡眠中的0号进程选新进程，如果没有就绪进程，要一直等待中断，不知道等多久才会有一个IO操作结束引发的中断。但是时钟中断是确定时间内会发生的，与IO操作无关。那么对于整秒时的时钟中断，之前规定的是中断前在用户态才会在整秒时执行耗时的事务处理，加用户态这样的限定条件的初衷是怕耽误重要的核心态任务，可是永远处于核心态的0号进程现在是无事可做的，应该让它去执行耗时的事务处理。如果不让它去做事务处理，会发生极端情况：一直不让0号进程做耗时的事务处理，系统的钟停了，所以进程的p_time不会改变，如果没有IO中断，那么系统会一直停留在swtch的中间一棒。所以要给0号进程执行耗时的事务处理的权限，将“中断前在核心态则返回的条件改成：

<img src=".\assets\image-20241123193440612.png" alt="image-20241123193440612" style="zoom:67%;" />

才返回，否则执行耗时的事务处理。

因为0号进程在做中间一棒的时候是高睡状态，不满足SRUN，所以会去执行耗时的事务处理。

这也解释了为什么一定要让0号进程来做swtch的中间一棒，不能让原进程做：

如果让原进程去做，同样面对上述提到的情况，原进程没有执行耗时的事务处理的权力，可能会导致系统中时钟停止，一直停留在swtch的中间一棒永远无法执行下去。没有办法设置一个条件来让原进程获得执行事务处理的机会，但是有办法设置条件让0号进程获得权力，因为0号进程与众不同在于它做中间一棒时是睡眠态。

<img src=".\assets\image-20241123193917645.png" alt="image-20241123193917645" style="zoom:80%;" />

综上，0号进程做三件事：

1. 醒着时候分配内存，进程换进换出
2. 睡着时候分配CPU，做swtch中间一棒
3. 在整秒时执行时钟中断的耗时事务处理



# 第五章 设备管理

<img src=".\assets\image-20241205151345998.png" alt="image-20241205151345998" style="zoom:80%;" />

## IO硬件系统

### 输入输出设备的分类

- 按设备的使用特性分类
  - 存储设备：外存、后备存储器。存取速度较内存慢，但容量比内存大得多，价格便宜。（与内存的交互）
  - 输入/输出设备：键盘、鼠标、扫描仪、视频摄像；打印机、绘图仪、显示器、音像输出设备等。（与人的交互）
- 按设备的传输速率分类 
  - 低速设备：传输速率为每秒几个字节至数百个字节。典型设备有**键盘、 鼠标器**、语音的输入和输出等。 
  - 中速设备：传输速率在每秒钟数千个字节至数万个字节。典型设备有行式**打印机**、激光打印机等。 
  - 高速设备：传输速率在数万个字节至数十兆字节。典型的高速设备有磁带机、 **磁盘机**、光盘机等。
- 按信息交换的单位分类
  - 块设备：信息的存取总是以数据块为单位。典型的块设备是**磁盘**。其传输速率较 高，通常每秒钟为几兆位；**可寻址，即可随机地读/写任一块。** 
  - 字符设备：信息的存取基本单位是字符。传输速率较低，通常每秒几个字节至数千个字节；**不可寻址**。
- 按设备的共享属性分类
  - 独占设备：临界资源，即一段时间内只允许一个用户（进程）访问。 （用完才释放）
  - 共享设备：在一段时间内允许多个进程并发访问的设备。 （但某一时刻仍然只允许一个设备访问）
  - 虚拟设备：利用大容量辅助存储器把**独享设备**改造成为能被多个进程共享的设备， 以提高独享设备的利用率。是一种逻辑上的I/O设备。

### 硬件接口

#### 设备控制器

在微机中，它通常是一块可插入主板扩展槽的电路板，也叫接口。是CPU与I/O设备之间的硬件接口，接收从CPU发来的命令，去控制一个或多个设备。

CPU与设备控制器接口、IO逻辑、设备控制器与IO设备接口三部分

<img src=".\assets\image-20241129091406235.png" alt="image-20241129091406235" style="zoom:80%;" />

#### 通道

通道：具有访问内存，执行I/O指令能力的特殊协处理器；数据的传送、I/O操作的组织、管理及其结束处理尽量独立于CPU。

<img src=".\assets\image-20241129091648541.png" alt="image-20241129091648541" style="zoom:67%;" />

<img src=".\assets\image-20241129091707682.png" alt="image-20241129091707682" style="zoom:67%;" />

IO通道是一种特殊的处理机，它具有执行IO指令的能力，并通过执行通道（IO）程序来控制IO操作。但IO通道又与一般的处理机不同，主要表现在：

1. 指令类型单一，由于通道硬件比较简单，其所能执行的指令，主要局限于与IO操作有关的指令
2. 通道没有自己的内存，通道所执行的通道程序是放在主机的内存中的，就是通道与CPU共享内存

##### 通道类型

<img src=".\assets\image-20241129092518914.png" alt="image-20241129092518914" style="zoom:50%;" />

###### 字节多路通道

以字节为单位传输信息。**每个设备分时占用一个很短的时间片**，不同的设备在各自分得的时间片内与通道建立连接，实现数据的传输。

类似于分时系统

适用于低速设备

<img src=".\assets\image-20241129092208947.png" alt="image-20241129092208947" style="zoom:50%;" />

###### 数据选择通道

字节多路通道不适于连接高速设备。由于数据传输率很高，通道在传送两个字节之间只有很少的空闲时间。 

连接多个高速设备，仅一个分配型的通道，在一段时间内只能执行一道通道程序，执行完后转向下一通道。

类似于单道批处理系统

适用于高速设备

<img src=".\assets\image-20241129092338037.png" alt="image-20241129092338037" style="zoom:80%;" />

###### 数组多路通道

数据选择通道使得在一个时段内通道被某设备独占，即使没有数据传送也无法共享通道，利用率低。 

结合字节多路通道和数据选择通道：以分时方式同时执行多道通道程序，每执行完一条通道指令转向下一通道。

类似于多道批处理系统

适用于中速设备

<img src=".\assets\image-20241129092449243.png" alt="image-20241129092449243" style="zoom:80%;" />

##### ”瓶颈“问题

<img src=".\assets\image-20241129092539463.png" alt="image-20241129092539463" style="zoom:50%;" />

由于通道价格昂贵，致使机器中所设置的通道数量势必较少，这往往又使它成为了IO的瓶颈，进而造成整个系统吞吐量的下降。

例如上图，假设设备1至设备4是4个磁盘，为了启动磁盘4，必须使用通道1和控制器2.但若这二者已经被其他设备占用，必然无法启动磁盘4。

解决瓶颈问题的最有效方法，便是增加设备到主机间的通路，而不增加通道，把一个设备连接到多个控制器上，而一个控制器 又连接到多个通道上。如上图，每个设备都有4条通往存储器的通路。多通路方式不仅解决了瓶颈问题，而且提高了系统的可靠性，因为个别通道或者控制器的故障不会使设备和存储器之间没有通路。

## IO软件系统

输入输出软件的层次结构：

<img src=".\assets\image-20241129093840596.png" alt="image-20241129093840596" style="zoom:50%;" />

### 设备驱动程序

<img src=".\assets\image-20241129093958594.png" alt="image-20241129093958594" style="zoom:50%;" />

有三种类型：

- 为每类设备设置一个进程（无工作则入睡）
- 在整个系统中设置一个I/O进程
- 专用的设备处理程序模块供调用（不是进程，UNIX采用这种）

### 设备无关软件

在现代操作系统中，为了提高操作系统的可适应性和可扩展性，都毫无例外地实现了设备独立性，也称设备无关性。其基本含义是：**应用程序独立于具体使用的物理设备**。为了实现设备独立性而引人了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名称来请求使用某类设备；而系统在实际执行时,还必须使用物理设备名称。因此,系统须具有将逻辑设备名称转换为某物理设备名称的功能,这非常类似于存储器管理中所介绍的逻辑地址和物理地址的概念。
在实现了设备独立性的功能后,可带来以下两方面的好处。
（1）设备分配时的灵活性
当应用程序（进程）以物理设备名称来请求使用特定的某台设备时，如果该设备已经分配给其他进程，而此时尽管还有几台其他的相同设备正在空闲，该进程却仍然阻塞。但若进程能以逻辑设备名称来请求某类设备时，系统可立即将该类设备中的任何一台分配给进程，仅当所有此类设备全部分配完成时，进程才会阻塞。
(2)易于实现 I/O重定向
所谓 I/〇 重定向，是指用于 I/〇操作的设备可以更换（即重定向），而不必改变应用程序。例如，在调试一个应用程序时，可将程序的所有输出送往屏幕显示；而在程序调试完成后，如需正式将程序的运行结果打印出来，此时便须将I/O重定向的数据结构——逻辑设备表中的显示终端改为打印机，而不必修改应用程序。I/〇重定向功能具有很大的实用价值，现已被广泛地引入到各类操作系统中。

功能：

1. 逻辑设备名到物理设备名的映射，确定相应物理设备的驱动程序 

   <img src=".\assets\image-20241129094845158.png" alt="image-20241129094845158" style="zoom:50%;" />

2. 设备的分配和释放 

   <img src=".\assets\image-20241129095002034.png" alt="image-20241129095002034" style="zoom:50%;" />

   重复执行次数或时间：由于外部设备在传送数据时容易发生数据传送错误，因此在很多系统中，如果发生传送错误，并不立即认为传送失败，而是令它重新传送，并由系统规定设备在工作中发生错误时应重复执行的次数。在重复执行时，若能恢复正常传送，则仍认为传送成功。仅当屡次失败，致使重复执行次数达到规定值而传送仍不成功时，才认为传送失败。

   <img src=".\assets\image-20241129095116376.png" alt="image-20241129095116376" style="zoom:50%;" />

   

   <img src=".\assets\image-20241129095140466.png" alt="image-20241129095140466" style="zoom:50%;" />

3. 设备保护，禁止用户直接访问设备 

4. 缓冲管理与差错控制 

   缓存管理 

   - 缓和CPU与I/O设备间速度不匹配的矛盾
   - 减少对CPU的中断频率
   - 提高CPU和I/O设备之间的并行性

   <img src=".\assets\image-20241129100611413.png" alt="image-20241129100611413" style="zoom:50%;" />

   <img src=".\assets\image-20241129100803552.png" alt="image-20241129100803552" style="zoom:50%;" />

   <img src=".\assets\image-20241129100817745.png" alt="image-20241129100817745" style="zoom:50%;" />

   <img src=".\assets\image-20241129100851636.png" alt="image-20241129100851636" style="zoom:50%;" />

5. 向用户层软件提供统一接口

### 用户进程

两种方式向内核提交I/O请求： 

- 库函数（高级语言）
- I/O系统调用（嵌套汇编INT80，效率更高）

### 虚拟设备的分配：SPOOLING技术

（SimultaneousPeripheralOperatingOnLine，假脱机操作）将一台I/O设备虚拟成多台逻辑I/O设备

为了缓和CPU的高速性与I/〇设备低速性间的矛盾而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上；或者相反。事实上，当系统中引人了多道程序技术后，**完全可以利用其中的一道程序来模拟脱机输入时的外围控制机功能，把低速I/〇设备上的数据传送到高速磁盘上；再用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。**这样，便可在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与CPU对数据的处理同时进行。

SPOOLing 系统是对脱机输入、输出工作的模拟，它必须有高速外存的支持，这通常采用**磁盘**。SPOOLing系统主要有以下三部分：

(1)输入井和输出井。这是在**磁盘上**开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘，输出井是模拟脱机输出时的磁盘。
(2)输入缓冲区和输出缓冲区。这两个缓冲区是在**内存**中开辟的。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据，以后再传送给输出设备
(3)输入进程 SPi 和输出进程 SPo。**进程 SPi模拟脱机输入时的外围控制机。进程SPo模拟脱机输出时的外围控制机。**

<img src=".\assets\image-20241129102733958.png" alt="image-20241129102733958" style="zoom:50%;" />

共享打印机技术已被广泛地用于多用户系统和局域网络中。当用户进程请求打印输出时，SPOOLing 系统同意为它打印输出，**但并不真正立即把打印机分配给该用户进程**，而只为它做两件事:①由输出进程在输出井中为之申请一个**空闲磁盘块区**,并将要打印的数据送入其中;②输出进程再为用户进程申请一张**空白的用户请求打印表**，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。如果还有进程要求打印输出，系统仍可接受该请求，也同样为该进程做上述两件事。
如果打印机空闲，输出进程将从请求打印队列的队首取出一张请求打印表，根据表中的要求，将要打印的数据从输出井传送到内存缓冲区，再由打印机进行打印。打印完后，输出进程再查看请求打印队列中是否还有等待打印的请求表。若有，则再取出队列中的第1张表，并根据其中的要求进行打印，如此下去。直至请求打印队列空，输出进程才将自己阻塞起来。仅当下次再有打印请求时,输出进程才被唤醒。

SPOOLing系统具有如下主要特点：

1. 提高了 I/O 的速度。这里对数据所进行的 I/O操作，已从对低速设备进行的 I/O操作，演变为对输入井或输出井中数据的存取，如同脱机输入输出一样，提高了 I/O 速度，缓和了 CPU 与低速设备之间速度不匹配的矛盾。
2. 将独占设备改造为共享设备。因为在SPOOLing系统中，**实际上并没有为任何进程分配设备**，而只是在输入井或输出井中为进程分配一个存储区和建立一张I/〇请求表，这样便把独占设备改造为共享设备。
3. 实现了虚拟设备功能。宏观上，虽然是多个进程在同时使用一台独占设备，而对于每一个进程而言，它们都会认为自己是独占了一个设备。当然，该设备只是逻辑上的设备。SPOOLing 系统实现了将独占设备变换为若干台对应的逻辑设备的功能。

## 磁盘存储器管理

### 磁盘结构

<img src=".\assets\image-20241129103720262.png" alt="image-20241129103720262" style="zoom:80%;" />

每条磁道上存储相同数目的二进制位，这样，磁盘密度即每英寸中所存储的位数，显然是内层磁道的密度高于外层

磁盘的编址方式与地址转换：

<img src=".\assets\image-20241129103804405.png" alt="image-20241129103804405" style="zoom:80%;" />

计算题：

<img src=".\assets\image-20241129104909716.png" alt="image-20241129104909716" style="zoom:80%;" />

本题是先存柱面

如果改成先存盘片：

一个盘片有100个磁道，每个磁道8个扇区，所以每个盘片有800个扇区

3680除以800等于4余480，所以在4号磁道

480除以8等于60，所以在60号柱面，0号扇区

<img src=".\assets\image-20241129105551636.png" alt="image-20241129105551636" style="zoom:50%;" />

### 提高磁盘读写效率的方法

:star2:最外侧磁道数为0

（1）磁盘调度算法（减少寻道时间） 

- 先来先服务FCFS：简单，但平均寻道距离较大
- 最短查找时间优先调度SSTF：可能导致进程饿死
- 扫描SCAN（电梯算法）：磁头向磁道增加方向运动，避免进程饿死
- 循环扫描CSCAN（单向电梯）：比电梯算法简单，往圆心走，回到最外圈的过程中什么都不做

<img src=".\assets\image-20241202155622543.png" alt="image-20241202155622543" style="zoom:50%;" />

<img src=".\assets\image-20241202155647088.png" alt="image-20241202155647088" style="zoom:50%;" />

（2）磁盘高速缓存（重复读，延迟写，预读）

<img src=".\assets\image-20241202155916071.png" alt="image-20241202155916071" style="zoom:50%;" />

具体见下一节

## UNIX字符块设备管理

### 缓存管理

UNIX在内存中设置高速缓存的目的：

1. 提高CPU与文件存储设备工作的并行程度
2. 力争重复使用已在缓存中的文件字符块，以减少对文件存储设备的读写次数，提高文件系统信息的读写速度和效率

文件存放在磁盘等存储介质上时，在物理上是以块为单位来组织的。

<img src=".\assets\image-20241202225400732.png" alt="image-20241202225400732" style="zoom:50%;" />

用户程序是从0开始的逻辑块，文件系统负责：把逻辑块转成物理块（物理块是把磁盘块拉成一条线得到的），设备管理系统负责：对于一个物理块，先去找一个缓存，如果成功找到，再完成物理块一维地址到磁盘具体三维地址的变换，把磁盘中的内容放进缓存。后续是缓存和内存之间的交换，而非磁盘与内存。用户看起来像是物理块与逻辑块的直接转换（文件系统），实际上是通过缓存完成的读写操作

缓存是内核区的一个线性数组，15个512字节

每次读写开始之前，首先要建立一个数据盘块和一个缓存的关联

用户地址空间和磁盘的数据交换通过内存中的高速缓存来完成

一定要拿到缓存才能继续，如果拿不到缓存会去睡觉



IO操作：

- 读操作：将磁盘块读到缓存，再从缓存读到内存。读操作结束指的是已经将缓存读到内存。此时缓存中的内容与盘块内容一致。对于一次读操作，如果所需字块已经在某一缓存中，则不需要一次真正的读操作，直接重用缓存
- 写操作：内存写到缓存，缓存再写到磁盘。在一次写操作结束时，如果缓存没有写满，考虑到短时间内可能还会继续写下去，所以此时并不急于进行真正的写操作，保持缓存中的内容，而将真正的写操作推迟到某个恰当时刻进行

”对于一次读操作，如果所需字块已经在某一缓存中“的判断依据就是这个字块的盘块号，所以后续的判断是否重用的函数GetBlk的参数GetBlk(dev,blkno)依据的就是设备号和盘块号

注意，blkno叫做“磁盘逻辑块号”，就是磁盘的盘块号

Buf：Buffer Control Block 缓存控制块

<img src=".\assets\image-20241202225915767.png" alt="image-20241202225915767" style="zoom:60%;" />

b_flag是标志位中一个或多个按位或的结果

B_DONE：IO操作是否结束

B_BUSY：是否分配

<img src=".\assets\image-20241202230236779.png" alt="image-20241202230236779" style="zoom:80%;" />

<img src=".\assets\image-20241202230423668.png" alt="image-20241202230423668" style="zoom:80%;" />

每次缓存使用（重新分配，重用）完毕，从队尾重新排队

重新分配后才离开原来的设备队列

重用的话不离开原来的设备队列

<img src=".\assets\image-20241202230514900.png" alt="image-20241202230514900" style="zoom:80%;" />

两对指针（蓝框），一对是b_forw和b_back，另一对是av_forw和av_back。一共是4个buf。每一个buf同时位于两个队列当中

四组指针（黄框和红框），每一组用于一个队列，每一个队列都是双向链表

<img src=".\assets\image-20241202230525390.png" alt="image-20241202230525390" style="zoom:80%;" />

读写时，先找本设备队列

- 找到证明可重用：

  - 如果是B_DONE，说明可以立即重用，并且说明该缓存在自由队列中，重用后会被放到自由队列队尾（”重用后会被放到自由队列队尾“这句话是最后的结果，真正的详细过程是：发现可以立即重用后，设置B_BUSY，B_DONE还在，移出自由队列，设备队列位置没动，因为B_DONE还在，即不用IO，从缓存直接拿，所以非常快的结束后，删除B_BUSY，放到自由队列队尾）

    如果自由队列中找到的这个缓存块有B_DELWRI标志，如果是读操作：B_DELWRI表明当前这个缓存块的数据比磁盘上的数据新，所以直接读缓存就行了。相当于重用该缓存块，放到自由队列队尾去；如果是写操作：更新该缓存块，如果更新后写到了块的末尾，该块要去执行真正IO，离开自由队列进入IO请求队列，再去找自由队列的新队头；如果更新后没有写到块的末尾，则继续延迟写，相当于重用，会在用完后放到自由队列末尾

  - 如果是B_BUSY，说明IO正在进行，设置B_WANTED然后入睡，睡在该缓存控制块上（体现了“不会给同一个物理块分配两个缓存“的思想），等待其他进程的IO操作结束wakeupall会被一起唤醒，再去本设备队列找，就会找到可重用了

- 找不到证明需要重新分配：

  - 如果自由队列不是空的，从自由队列队首取缓存，设置B_BUSY

    - 如果含B_DELWRI：

      设置B_ANYSC（异步写），调用Bwrite(bp)，再去找自由队列的新队首（“再去找自由队列的新队首”也是最后的结果，具体的过程是：调用Bwrite(bp)，真正执行写操作，从缓存写到磁盘，Bwrite函数会把该缓存挂到IO请求队列的队尾，移出自由队列，而该操作是异步的，也就是getBlk不会等待这次写结束再继续下去，会立刻继续执行，也就是立刻重新寻找自由队列，这时自由队列的队首就变成下一个缓存块了
  
    - 如果不含B_DELWRI：
  
      清B_BUSY外所有标志位，从原设备队列摘下，插入新设备队列队头（注意是队头），return(bp)后，Bread或者Bwrite函数会把它挂到请求队列队尾
  
  - 如果自由队列是空的，在自由队列的队头设置B_WANTED然后入睡，睡在自由队列的队首指针上

精确的LRU算法：为了使得一个已被释放的缓存尽可能长的保持原来的使用状态，将它送入自由队列的尾部，而在分配内存时又从自由队列的首部取出。当一个缓存在自由队列内移动时，只要有按原状使用它的需要，就立即将它从自由队列里抽出。当它再次被释放时又进入了自由队列的末尾。这样就保证了在所有自由缓存中，淘汰最后一次使用时间离现在时刻最远的一个缓存内容，也就是自由队列的队首。

注意，设备队列每次插入都是在队头插，自由队列和IO请求队列是队尾

<img src=".\assets\image-20241206154625142.png" alt="image-20241206154625142" style="zoom:50%;" />

【情况1】如果此时进程pa读取该设备上的398号数据块

设备队列找到，可重用，但B_BUSY，398号会设置B_WANTED然后pa入睡

【情况2】如果此时进程pa读取该设备上的94号数据块

设备队列找到，且是在自由队列，可直接重用，因为是读操作，延迟写的缓存块中内容比磁盘新，所以直接读缓存块，不用真正执行读磁盘，重用后94被放到自由队列末尾，在设备队列中位置不变

【我加一个情况】如果此时进程pa写该设备上的94号数据块

设备队列找到，且是在自由队列，可直接重用，如果写到了94号块的末尾，则94会离开自由队列，到IO请求队列去，自由队列的队头变成78；如果没写到94号块的末尾，相当于重用，重用后94被放到自由队列末尾，在设备队列中位置不变

【情况3】如果此时进程pa读取该设备上的100号数据块

100不在设备队列中，所以会拿自由队列的队头重新分配给100。自由队列的队头是94，有延迟写标志，现在它要被重新分配了，所以要执行写操作写回94号物理块了。94会离开自由队列，到IO请求队列去，自由队列的队头变成78。78重新分配，离开0#块设备队列，78改为100，插入新的设备队列的队头（但这个新的设备队列在本题中依旧是0#块设备）

### 块设备读写过程

#### 读操作

读操作流程：

①确定需要读取的内容所在的逻辑盘块号

②分配一个缓存

③完整盘块读入缓存（DMA以盘块为单位）

④需要的内容复制（从缓存复制到用户地址空间，用户需要的是一些字节，不是整个盘块，“需要的内容”指的是文件系统会把用户实际需要的字节复制）

<img src=".\assets\image-20241206163344530.png" alt="image-20241206163344530" style="zoom:80%;" />

UNIX的读操作都是同步读：如果B_DONE，直接重用，不用入睡；否则要入睡等待读操作结束，高睡，优先级-50（IO操作读写都是-50）。不管睡不睡（如果没睡就直接返回文件系统，如果睡了就等唤醒后重新上台返回文件系统，下图中的最下面一行），因为读操作结束后还需要把需要的内容复制到用户地址空间，所以此时还不释放缓存，会等到文件系统使用完之后释放，到自由队列队尾去

<img src=".\assets\image-20241206164512860.png" alt="image-20241206164512860" style="zoom:80%;" />

启动设备驱动是指：

<img src=".\assets\image-20241206163849602.png" alt="image-20241206163849602" style="zoom:50%;" />

在IO请求队列中的第一个缓存块需要执行ATABlockDevice::Start()，调用ATADriver::DevStart(bp) 启动磁盘执行本次I/O请求。非队头的缓存块不用执行，会是请求队列排在它前一位的缓存块在中断返回前启动驱动（下图中的③）

<img src=".\assets\image-20241206164347143.png" alt="image-20241206164347143" style="zoom: 33%;" /> <img src=".\assets\image-20241206171104717.png" alt="image-20241206171104717" style="zoom:50%;" />

IO完成的中断返回前调用 IOdone(bp)，如果是异步操作则没有进程在等待本次IO结束后唤醒，会直接把缓存释放掉；如果是同步操作则有进程在等待IO而睡觉，wakeupall会唤醒两类进程：因本次IO而睡的进程和缓存重用但因在IO而睡的进程

中断完成的IO善后处理工作：

①检查错误（最多重发10次，超过10次则设置出错标志，表示这种错误不能靠重复执行的方法来排除）

②唤醒进程

③为下一个请求启动驱动，**中断处理中实现了IO操作连续不断地处理**

代码执行流程：

<img src=".\assets\image-20241206164600832.png" alt="image-20241206164600832" style="zoom:80%;" />

#### 写操作

写操作流程：

①确定需要写入的内容所在的盘块号

②分配一个缓存

③写入缓存（从内存写到缓存）

④完整的缓存写入盘块（因为读写磁盘是以完整盘块为单位，当写入部分不足一个盘块时，文件原有信息丢失）

为了解决④中问题，根据写入位置的不同分情况处理

<img src=".\assets\image-20241206164817894.png" alt="image-20241206164817894" style="zoom:80%;" />

正好完整写一个块，就直接异步写

不是完整一个块的话：如果本次已经写到了块的最后一个字节，直接异步写；如果没有写到最后一个字节，延迟写，不实际IO

延迟写被真正写回的条件：多次重写，直到某一次写到缓存块的末尾；或者移到了自由队列队头要被重新分配了

<img src=".\assets\image-20241206172026360.png" alt="image-20241206172026360" style="zoom:80%;" />

如果是同步写，直接调用BufferManager:: **Bwrite**(Buf* bp)，写完唤醒进程之后释放缓存块

如果是异步写，调用的是BufferManager:: **Bawrite**(Buf* bp)（这里面其实就是加B_ASYNC 后调用Bwrite），Bwrite中不释放，等IO中断返回前负责释放

如果是延迟写就是根本不写，放到自由队列队尾去

举例：

要写物理块的500-1400字节：

涉及到了0号物理块的后半部分，1号物理块的全部，和2号物理块的前半部分

【对于0号物理块】因为写到了缓存块的末尾并且不是整个块（存在覆盖问题），先读，再异步写（把磁盘内容读到缓存，更新缓存内容后，从缓存写到磁盘）

【对于1号物理块】完整写一个块的512字节，直接异步写

【对于2号物理块】不是整个块而且也没有写到块的末尾，先读，再延迟写

那么在实际应用中，写操作大概率不会正好写一个完整的缓存块，其他的情况都需要先读再写，所以会认为写操作比读操作更耗时

#### 缓存的竞争使用问题

<img src=".\assets\image-20241206173424894.png" alt="image-20241206173424894" style="zoom:80%;" />

在同步读写情况下，IOdone只是设置了B_DONE，没有删除B_BUSY，会唤醒上述两类进程。UNIX的处理机制是：即使等待重用缓存入睡的进程先上台，也会因为B_BUSY而再次下台。就保证了等待IO入睡的进程一定会优先上台执行

<img src=".\assets\image-20241206174541782.png" alt="image-20241206174541782" style="zoom: 80%;" />

可以认为B_BUSY封锁了当前缓存块的使用权，一个进程IO时分配了一个缓存块，进程给缓存块设置B_BUSY，这时就不允许别的进程来用这个缓存块了，IO中断返回前当前的台上进程也没有权利解除这个封锁，要等到这个发起IO的进程唤醒重新上台之后再自己解除封锁，这之后其他等待重用该缓存块的进程才能使用

解除封锁发生在缓存块释放中，BufferManager::Brelse(bp)

如果有进程在等着重用缓存：

<img src=".\assets\image-20241206174353547.png" alt="image-20241206174353547" style="zoom:80%;" />

如果有进程在等着自由缓存：

<img src=".\assets\image-20241206174406723.png" alt="image-20241206174406723" style="zoom:80%;" />

#### 提高磁盘读写效率的方法

1. 磁盘调度算法（减少寻道时间） 
2. 磁盘高速缓存（重复读，延迟写，预读）

如果用户进程在顺序读文件时，能够将用户即将要读到的东西预先读到缓存里，当用户真正需要的时候，就可以重用该缓存，减少IO。

用户顺序读文件的判断：上次读的第i块，这次读i+1块，下次很可能读i+2块。

<img src=".\assets\image-20241206174800534.png" alt="image-20241206174800534" style="zoom:80%;" />

正常读是同步读，但是预读是异步读（所以说UNIX中所有的读操作都是同步读是错误的吧）

在预读的时候，也是先去找缓存，如果找到可重用的，就把这个缓存块直接释放掉；如果没找到，要分配一个，异步读，理论上异步读操作的缓存块释放是在IO中断里，但预读要在现在直接释放（不去打扰进程）

直接释放的原因：预读块在自由缓存队列的时间里，进程如果需要（预测对），则可以随时重用； 预读块到达自由缓存队列队头， 如果进程都没有用过（预测失败），则由GetBlk分配给其他盘块。

预读是异步读，后续只有当它到达自由队列队头，要被重新分配时，才会被释放。如果长时间不使用该缓存包含的信息，它没有到达队头没有被释放，变成了被某个进程占用但又不使用的资源。

注意，如果这个预读选中的缓存块，是之前被设置过延迟写的块这个缓存块中的数据比磁盘新，所以直接重用，要在现在释放缓存块。释放缓存块的时候，是没有删除B_DELWRI的，所以延迟写的内容不会因为预读而丢掉，也就是说这个缓存块会带着B_DELWRI去到自由队列的队尾。

何时判定为预测失败，不是固定的，取决于系统中的IO繁忙程度

在UNIXV6++中，试说明缓存控制块Buf有无可能，在什么样的条件下出现下列情况： 

1. 同时处在自由Buf和一个设备Buf队列中：

   IO操作完成，缓存已释放：有B_DONE，无B_BUSY 

   只有发起IO的进程把缓存块释放以后才会删除B_BUSY才会进入自由队列

2. 同时处在某一设备Buf队列和I/O请求队列中：

   IO操作正在进行中，无B_DONE，有B_BUSY 

3. 同时处在自由Buf和NODEVBuf队列中：

   系统初启完成初始化 

4. 只处在某一设备Buf队列中：

   Getblk中找到可以重用的缓存，将其从自由队列中摘下，返回给文件系统，但是仍然保持在原设备队列中：有B_DONE，有B_BUSY 

   这是一个瞬时状态，当文件系统用完，就会释放，该块就会回到自由队列当中

   只有读操作会发生这个瞬时状态，要等文件系统把需要的内容读到用户地址空间之后才算完成，才会释放；对于写操作，要么是真正写会去到IO请求队列，要么是延迟写留在自由队列，不会出现等待文件系统而只存在于设备队列的瞬时状态

5. 只处在自由Buf队列中：

   不可能出现，要么是系统初启时自由+NODEV，要么是其他情况下设备+自由，不可能单独出现在自由队列

   课本上写：一个自由缓存块除了在自由队列，一定在某个设备缓存队列中，为此，在系统初启阶段将它们全部送入NODEV队列

6. 只处在某一设备的I/O请求队列中：

   不可能，一定还处在该设备的设备队列中

7. 只处在NODEVBuf队列中：

   不可能，NODEV是在系统初启时，此时也在自由队列中

8. 同时出现在自由Buf、某一设备的Buf队列和I/O请求队列中

9. 同时出现在一类设备的Buf队列、另一类设备的I/O请求队列中

对于8和9， 不可能同时出现在3个队列中



# 第六章 文件管理

## 文件系统概述 

文件是具有文件名的一组相关信息的集合。 

通常，文件由若干个记录组成。 

系统或用户可以将一个程序或一组数据命名为一个文件。

操作系统中与管理文件有关的软件和数据统称为**文件管理系统**（简称文件系统）。

- 从**系统角度**，文件系统是对文件的存储空间进行组织、分配，负责文件的存储并对存储的文件进行保护、检索的系统。 
- 从**用户角度**，文件系统主要实现了对文件的按名存取。

文件系统模型：

<img src=".\assets\image-20241209154230446.png" alt="image-20241209154230446" style="zoom:50%;" />

对目录的组织和管理是方便用户和提高对文件存取速度的关键

文件的类型：UNIX就是按照组织形式分类，把设备也看作文件

可执行和调用是一个意思，只允许调用执行，不允许读和写

<img src=".\assets\image-20241209154407131.png" alt="image-20241209154407131" style="zoom:50%;" />

文件系统的主要功能：

1. 按用户要求创建或删除文件
2. 按用户要求进行文件读写
3. 用户使用文件符号名实现文件访问，**文件的物理组织对用户是透明的**
4. 管理文件存储空间，自动分配，建立文件逻辑结构以及物理结构之间的映照关系
5. 共享和保密

### UNIX文件系统

<img src=".\assets\image-20241209155315264.png" alt="image-20241209155315264" style="zoom:80%;" />

**文件的创建：**

<img src=".\assets\image-20241209160316200.png" alt="image-20241209160316200" style="zoom:50%;" />

1. 首先目录搜索name文件是否存在：

   - 如果之前的路径都正确：
     - 该文件不存在，则创建该文件，长度为0
     - 该文件存在，则将原文件内容全部删除
   - 如果之前的路径不正确：返回错误

2. 然后设置文件访问权限：

   <img src=".\assets\image-20241209160426449.png" alt="image-20241209160426449" style="zoom:50%;" />

3. 以可写的方式打开文件

**文件的打开：**

<img src=".\assets\image-20241209160949918.png" alt="image-20241209160949918" style="zoom:50%;" />

打开时先目录搜索该文件是否存在，再看文件访问是否合法（文件主/同组/其他）

**所有对文件的操作**进行之前，必须先**打开文件**，获得**文件标识符 （文件句柄）**

比如文件的关闭：

<img src=".\assets\image-20241209161633079.png" alt="image-20241209161633079" style="zoom: 50%;" />

就不再用name了，而是用fd

**文件的顺序读写：**

<img src=".\assets\image-20241209162056073.png" alt="image-20241209162056073" style="zoom:50%;" />

文件创建时，读写指针指向文件的开头，此后每次读写都向后移动

n不一定等于nbytes

读操作：如果n<nbytes可能是①磁盘文件坏掉②文件大小本身不足nbytes字节

写操作：如果n<nbytes只可能是磁盘文件坏掉

**文件的随机存取：**是系统调用

<img src=".\assets\image-20241209162132390.png" alt="image-20241209162132390" style="zoom: 50%;" />

文件的勾连与取消：

<img src=".\assets\image-20241209162209482.png" alt="image-20241209162209482" style="zoom:50%;" />

如果想要把文件从name1改名叫name2，就是把两句话一起用

link(name1,name2)

unlink(name1)

如果某文件只有一个文件名，那么取消该文件名的话，就是取消该文件

类似于windows的快捷方式

物理上只有1个，增加的是逻辑路径

## 文件的逻辑结构与物理结构

**文件的逻辑结构**指的是：**从用户角度（应用程序层）观察到的文件的组织形式**， 是程序可直接处理的数据及其结构。是由操作系统提供给上层应用的文件的逻辑地址。

文件的逻辑地址空间是一维的： <逻辑块号**lbn**> （一个逻辑块大小和物理块相同， 从文件起始位置开始）

**文件的物理结构**指的是：文件在**存储介质上**由操作系统如何保存

### 文件的物理结构

文件的物理存储方式：

- 连续结构文件：为每个文件分配一组相邻接的盘块。文件存放在**连续编号的物理块**中。保证了文件中逻辑顺序与占用盘块顺序的一致性。

  <img src=".\assets\image-20241209163430333.png" alt="image-20241209163430333" style="zoom:80%;" />

- 链接结构文件：非连续的存储结构（将文件装入到**多个离散的盘块**中）。通过链接指针，将同属于一个文件的多个离散的盘块链接成一个**链表**。

  - 隐式链接

    <img src=".\assets\image-20241209163502286.png" style="zoom:80%;" />

    随机存取也需要从头去找，耗时

  - 显式链接

    文件分配表FAT在内存中，整个磁盘只有一张FAT

    <img src=".\assets\image-20241209163959165.png" alt="image-20241209163959165" style="zoom:80%;" />

- 索引结构文件：每个文件分配一个**索引块**（表），建立逻辑块号与物理块号的对照表。

  <img src=".\assets\image-20241209164144775.png" alt="image-20241209164144775" style="zoom:80%;" />

### UNIX文件索引节点

#### 外存索引节点

文件系统将磁盘从0柱面，0磁道，0扇区拉直，从0#盘块（物理块）开始顺序编号

<img src=".\assets\image-20241209165142318.png" alt="image-20241209165142318" style="zoom:80%;" />

**Inode区**

202~1023#盘块是Inode区，叫做外存文件控制块区

 i node  文件索引节点：文件控制块，FCB

每个文件在Inode区有一个外存文件控制块DiskInode （外存索引节点，64个字节）

<img src=".\assets\image-20241209165300991.png" alt="image-20241209165300991" style="zoom:60%;" />

 **d_mode：**16位

<img src=".\assets\image-20241209165418006.png" alt="image-20241209165418006" style="zoom:80%;" />

**d_nlink：**是该文件在目录树中不同路径名的数量，所以可知Inode是和物理上的文件一一对应，不会给逻辑上不同路径的相同文件分配多个Inode

**d_addr[10]：** 文件逻辑块号和物理块号转换的混合索引表

- 小文件：文件大小范围： 0～5盘块（文件最大6×512=3K）

  <img src=".\assets\image-20241209230534569.png" alt="image-20241209230534569" style="zoom:50%;" />

  lbn  = Offset / 512  lbn是逻辑块号，Offset是用户文件的偏移量，偏移量除以一个逻辑块的大小512，得到逻辑块号

  直接寻址，addr里面放的就是物理块号

- 大文件：7 ~（6+128×2=262）盘块称为大文件

  <img src=".\assets\image-20241209231607631.png" alt="image-20241209231607631" style="zoom:50%;" />

  一次间接寻址

  对于一个间接索引块，512字节，一个物理块的记录占4字节，所以间接索引块可容纳512/4=128条记录

  所以对于addr的6和7，分别对应一个间接索引块，每人对应128个逻辑块号

- 巨型文件：（6+128×2+1=263）~（6+128×2+128×128×2=33030）盘块称为巨型文件

  <img src=".\assets\image-20241209231958934.png" alt="image-20241209231958934" style="zoom:50%;" />

  二次间接寻址

  所以对于addr的8和9，分别对应一个二级间接索引块，每人对应128×128个逻辑块号
  
  注意，当addr8的二次间接索引块装满128条记录时，每一条记录都对应着一个一次间接索引块，也就是会有128个一次间接索引块

<img src=".\assets\image-20241209232322759.png" alt="image-20241209232322759" style="zoom:80%;" />

==**例题：**==

<img src=".\assets\image-20241209232812726.png" alt="image-20241209232812726" style="zoom:80%;" />

<img src=".\assets\image-20241209232832513.png" alt="image-20241209232832513" style="zoom:80%;" />

一共128个，减去6等于122，小于128，所以只用到了addr6，用不到addr7，所以只有一个索引块

<img src=".\assets\image-20241209232848417.png" alt="image-20241209232848417" style="zoom:80%;" />

一共4096个，减去6+128×2等于3934,128×128=16384，3934小于16384，所以只用到addr8，没用到addr9。前6个块：数据块6个；中间两个块：数据块2个，一级间接索引2个；最后一个块：二级间接索引1个，一级间接索引是3934/128=30个（注意计算方法就是，一个间接索引包含128个记录）

<img src=".\assets\image-20241209232901496.png" alt="image-20241209232901496" style="zoom:80%;" />

**superblock区**

SuperBlock占用两个盘块，一共1024个字节

<img src=".\assets\image-20241209233848255.png" alt="image-20241209233848255" style="zoom:80%;" />

s_ninode是SuperBlock直接管理的空闲inode个数 ≤100

 s_inode[100]是SuperBlock直接管理的空闲inode索引表

任何时候只管理s_ninode个空闲inode，按栈的方式使用

<img src=".\assets\image-20241209234045303.png" alt="image-20241209234045303" style="zoom:67%;" />

只有需要分配inode且栈为空时才会重新搜索找100个空闲inode

问题在于，栈顶先被用，最新被删除的文件的inode反而会最先被重新使用，不利于文件的恢复，不满足对于删除的文件尽量保留更长时间的原则

#### 内存索引节点

<img src=".\assets\image-20241209234836172.png" alt="image-20241209234836172" style="zoom:80%;" />

每个文件在Inode区有一个外存文件控制块DiskInode （外存索引节点，64个字节）

磁盘上的Inode节点会导致文件访问效率低

每个文件还有一个内存文件控制块Inode（内存索引节点）（内存副本）

内存inode表 Inode InodeTable::m_Inode[100]，所以最多可以open100个文件

<img src=".\assets\image-20241209234946360.png" alt="image-20241209234946360" style="zoom:80%;" />

<img src=".\assets\image-20241212221618421.png" alt="image-20241212221618421" style="zoom:80%;" />

这一部分是外存到内存对应过来的：

<img src=".\assets\image-20241209235350503.png" alt="image-20241209235350503" style="zoom:80%;" />

创建inode时从磁盘复制到内存，等到inode释放时，如果发生更改（比如文件长度变长i_size变，增加链接i_nlink变）要写回磁盘

i_lastr是用于预读判断的，i_lastr+1=lbn则预读

rablock是需要预读的物理块号

<img src=".\assets\image-20241209235504849.png" alt="image-20241209235504849" style="zoom:80%;" />

UNIX V6允许内存打开100个文件（inode和file），允许每个进程最多打开15个文件（user结构）

<img src=".\assets\image-20241212222204306.png" alt="image-20241212222204306" style="zoom: 80%;" />

可以看到fd是进程打开文件在文件表中的序号

在open之后全都用fd的好处是fd→user→file→inode全部在内存快速完成；如果始终使用文件名每次要到磁盘去查找，耗时

**i_count是引用计数，表明有几个flie指向inode**

**f_count是打开该文件的进程数，表明有几个进程指向file**

<img src=".\assets\image-20241209235936316.png" alt="image-20241209235936316" style="zoom:80%;" />

父进程pa创建子进程pb

<img src=".\assets\image-20241209235945861.png" alt="image-20241209235945861" style="zoom:80%;" />

父进程为子进程复制图像时，各种计数加1里面就有f_count加1。

<img src=".\assets\image-20241210000152523.png" alt="image-20241210000152523" style="zoom:80%;" />

只要是open就会创建一个file，内存inode的引用数就会加1（而不是再去创建一个inode）

子进程不一样（没有创建file，直接和父进程共用，把f_count加1）是因为它没有执行open而是复制的父进程图像。子进程如果不想和父进程共享，就要先close(fd)，再open(文件名)，只要执行open就会创建一个file

共用指的是同样的读写权限，同一个offset指针

而正常情况下，一个进程open会产生一个file，多个进程有不同的file，就会拥有不同的读写权限和不同的offset指针，它们打开同一个磁盘文件，但是独立读写

**实现多个进程之间以不同的读写权限和指针打开同一个磁盘文件的功能**就是设置file和inode两个结构而不是全放在inode的原因，把读写权限和读写指针都放在file而非inode

**便于文件共享，兼顾不同进程对相同文件的并发访问需求**。（便于文件共享指的是：2 个不同的路径名引用同一个磁盘文件，内存Inode 池共用同一个Inode 结构。 兼顾不同进程对相同文件的并发访问需求指的是：系统为每次文件打开操作分配一个File 结构，用以控制文件访问模式和当前读写位置。对同一个文件的多次打开操作对应于独立的多个file 结构，彼此互不干扰，这便为多个进程并发访问同一个文件提供了良好的数据结构基础）

注意，内存Inode是外存DiskInode的副本，并且二者之间存在一一绑定的关系，即任何DiskInode在内存中只可能有一个副本，**无论有多少进程需要访问该外存索引节点，它最多被载入内存一次，分配一个空闲内存Inode对象，该内存Inode由所有进程共享**

**关闭文件**时，只有当f_count <0或i_count <0时， 才需要释放相应的File结构或内存Inode

如果在下图的③，file>0，释放操作就此结束；同理④，inode>0，结束

<img src=".\assets\image-20241212222851410.png" alt="image-20241212222851410" style="zoom:80%;" />

### UNIX文件系统的读写操作

读写操作是系统调用

fd：文件标识符

buf：进程地址空间中存放读回数据/写入数据的首址

nbytes：读写的字节数

系统调用返回值n：实际读写字节数

offset不是传的参，系统自动维护，系统调用不可指定，只能通过seek修改

<img src=".\assets\image-20241212223658650.png" alt="image-20241212223658650" style="zoom:80%;" />

<img src=".\assets\image-20241212223710530.png" alt="image-20241212223710530" style="zoom:80%;" />

主要函数就是Rdwr(mode)，读写共用，用mode区分 mode = FREAD/ FWRITE

<img src=".\assets\image-20241212225725165.png" alt="image-20241212225725165" style="zoom:80%;" />

m_Base←buf 进程地址空间中存放读回数据/写入数据的首址

m_Offset←f_offset 不是传参，系统自动维护

注意，f_offset是文件读写位置指针，不是块内偏移

m_Count←nbytes 读写的字节数

返回值是实际读取的字节数

<img src=".\assets\image-20241212230316381.png" alt="image-20241212230316381" style="zoom:80%;" />

#### 读操作ReadI( )

<img src=".\assets\image-20241212230611521.png" alt="image-20241212230611521" style="zoom:80%;" />

逻辑块号lbn = m_Offset / 512

块内偏移offset = m_Offset % 512

注意，f_offset/m_Offset是文件读写位置指针，offset是块内偏移

本次需要读入的字节数 n = min(512 - offset, m_Count,文件剩余字节数)

m_Count是理论要读的字节数，但是如果大于文件剩余字节数是没有意义的，所以相当于是先min(m_Count,文件剩余字节数)得到实际要读的字节数，再去和当前块剩余空间去比较，块内偏移是offset，512-offset就是当前块可用大小

将逻辑块号变换为物理块号 intInode::Bmap(int lbn)，逻辑转物理后，块号改变，实际读的字节数n和块内偏移offset都没有改变

<img src=".\assets\image-20241212231014033.png" alt="image-20241212231014033" style="zoom:80%;" />

小型文件直接在内存找到，大型文件要访问一次磁盘找一级索引，巨型文件要访问两次磁盘找一级和二级索引。所以文件越大，读写速度越慢

【预读的条件】（就是下图的顺序读判断）

1.  i_lastr + 1 == lbn

2. 不需读入额外的索引块

   **如果当前lbn转换成物理块后发现是当前索引块的最后一块，这时候如果要做预读，还要再去访问磁盘一次读下一个索引块，不合算**

如果两个条件都满足，会将lbn+1所在的物理块号放进rablock

<img src=".\assets\image-20241212231324587.png" alt="image-20241212231324587" style="zoom:80%;" />

m_Count-n以后的值来判断是否读完

<img src=".\assets\image-20241212231822921.png" alt="image-20241212231822921" style="zoom:80%;" />

setPri的情况：

1. 如果直接拿到了可重用缓存在getBlk没有睡，直接重用不用真正IO在Bread没有睡，如果是小文件在转换物理号的时候也没有访问磁盘。这样的话全程没有睡觉，没有访问磁盘，速度会非常快，RunRun也不会被设置，不会下台
2. 如果没有自由缓存，睡眠等待；缓存是重新分配的，要真正IO，去睡；RunRun被设置，发生进程切换
3. 如果发生预读，是异步读，进程又不会去睡，有什么影响吗？？

题目：m_Base,m_Offset如图所示，理论读取字节数是m_Count=2.5×512，要读的文件实际长度只有2.25×512，

因为m_Offset在0.5块的位置，所以文件剩余字节数是1.75×512，也就是最终系统调用的返回值是1.75

注意，m_Offset是逻辑文件的读写指针位置，offset是块内偏移

<img src=".\assets\image-20241213093616385.png" alt="image-20241213093616385" style="zoom:80%;" />

第一个块：

lbn = m_Offset / 512=0

offset = m_Offset % 512=256

m_Count=2.5×512

文件剩余字节数=1.75×512

n = min(512 - offset, m_Count, 文件剩余字节数)=256

将逻辑块号转换得到物理块号，真正IO读到缓存，文件系统根据offset和n的值把这一整个块中真正需要的信息传到用户目标区，释放缓存

<img src=".\assets\image-20241213094415601.png" alt="image-20241213094415601" style="zoom:80%;" />

第二个块：

lbn = m_Offset / 512=1

offset = m_Offset % 512=0

m_Count=2×512

文件剩余字节数=1.25×512

n = min(512 - offset, m_Count, 文件剩余字节数)=512

将逻辑块号转换得到物理块号，真正IO读到缓存，文件系统根据offset和n的值把这一整个块中真正需要的信息传到用户目标区，释放缓存

注意，此时满足了i_lastr + 1 == lbn，会异步预读

<img src=".\assets\image-20241213094558024.png" alt="image-20241213094558024" style="zoom: 80%;" />

第三个块：

lbn = m_Offset / 512=2

offset = m_Offset % 512=0

m_Count=1×512

文件剩余字节数=0.25×512

n = min(512 - offset, m_Count, 文件剩余字节数)=0.25×512

将逻辑块号转换得到物理块号，但不一定要真正IO，取决于系统IO的繁忙程度：

1. 如果系统IO不繁忙，预读的缓存块还在自由队列，getBlk时会找到该缓存重用，不用真正IO
2. 如果系统IO繁忙，预读的缓存块已经走到自由队列队头被重新分配了，那么就要正常IO

<img src=".\assets\image-20241213094943314.png" alt="image-20241213094943314" style="zoom:80%;" />

文件读取结束，m_Count=0.75×512，系统调用的返回值是1.75块

#### 写操作WriteI( )

<img src=".\assets\image-20241213095131606.png" alt="image-20241213095131606" style="zoom:80%;" />

写完整一块的判断条件：offset=0且n=512。如果写的不是完整的一块，要先读再写

在写缓存结束时，用更新后的m_Offset来判断是否写到了一个块的末尾。如果上述满足了写完整一块，那一定会满足m_Offset恰好为下一块的首址；不是完整写一块也可能满足。

写操作极大可能文件变长，满足超出文件原长度，要修改内存inode中的文件大小i_size



## 文件存储空间管理

### 文件存储空间管理方法

位图法：

<img src=".\assets\image-20241216154208581.png" alt="image-20241216154208581" style="zoom:67%;" />

连续文件：

<img src=".\assets\image-20241216154315185.png" alt="image-20241216154315185" style="zoom:67%;" />

链接文件：

<img src=".\assets\image-20241216154330403.png" alt="image-20241216154330403" style="zoom:67%;" />

UNIX采用成组链接法：

<img src=".\assets\image-20241216154352131.png" alt="image-20241216154352131" style="zoom:67%;" />

### UNIX磁盘存储空间管理

<img src=".\assets\image-20241216155001093.png" alt="image-20241216155001093" style="zoom:80%;" />

<img src=".\assets\image-20241216155012386.png" alt="image-20241216155012386" style="zoom:67%;" />

superblock只会直接管理一个组，一个组里最多100个块

<img src=".\assets\image-20241216154807820.png" alt="image-20241216154807820" style="zoom:67%;" />

第1组的首盘块空闲是为了代表空闲盘块结束标志

管理方式是每一个组的首块直接管理下一个组

<img src=".\assets\image-20241216155351124.png" alt="image-20241216155351124" style="zoom:67%;" />

**空闲块的分配：**

<img src=".\assets\image-20241216155425399.png" alt="image-20241216155425399" style="zoom:50%;" />

每一个组，以从99号到0号的顺序分配。

当分配的是首块的时候，也就是s_nfree=0，一旦盘块分配出去，后续分组的盘块信息将丢失，所以先交出下一组的名单再走

<img src=".\assets\image-20241216160456287.png" alt="image-20241216160456287" style="zoom:80%;" />

**使用完毕块的回收：**

<img src=".\assets\image-20241216155718289.png" alt="image-20241216155718289" style="zoom:50%;" />

每一个组，以从0号到99号的顺序回收。

当回收的是s_nfree=100时，证明已经是下一个组的首块，而下一个的首块正好是刚刚写完的那个组的直接管理者。新收回的盘块做新的分组的组长，下一组的名单交给他

<img src=".\assets\image-20241216160533847.png" alt="image-20241216160533847" style="zoom:80%;" />

<img src=".\assets\image-20241216160546038.png" alt="image-20241216160546038" style="zoom:80%;" />

在系统初启时，superblock在内存创建副本，叫做文件系统的挂载

如果SuperBlock的内存被修改过，文件系统卸载时，需写回磁盘

<img src=".\assets\image-20241216161027244.png" alt="image-20241216161027244" style="zoom:67%;" />

盘块分配，分配缓存，把缓存清0，而不用一次IO去清理盘块，等以后写回磁盘时就清掉了原来的垃圾

### UNIX文件的长度变化

首先回顾写操作流程：

①确定需要写入的内容所在的盘块号

②分配一个缓存

③写入缓存（从内存写到缓存）

④完整的缓存写入盘块（因为读写磁盘是以完整盘块为单位，当写入部分不足一个盘块时，文件原有信息丢失）

如果不是完整的块，会延迟写；如果恰好是一个完整的块，会异步写

而写操作流程的第一步是逻辑块Bmap转换得到物理块，前提是没有超出文件原有长度，才会是已经分配了物理块的

写操作如果超出文件长度，是没有分配物理块的：

<img src=".\assets\image-20241216161313197.png" alt="image-20241216161313197" style="zoom:80%;" />

文件本身有三个块的长度

（1）文件增长，但没有超出当前逻辑块，正常写

就是正常的写操作流程，分配缓存，如果是写一整个完整的块512，就直接往缓存里写；如果不是512，先读后写

（2）文件继续增长，超出当前逻辑块，**Bmap得到的物理块号会是0**

分配新的物理盘块，分配缓存，设置延迟写B_DELWRI，缓存清0，直接释放

为什么要释放在后面的例题解释

（3）文件继续增长，需要新的一级索引块

和2的区别就是，都是要申请一个块，但用途从数据块变成了索引块，然后把申请到的缓存清0，在索引块上找数据块时，因为都是0，所以再去申请数据块

（4）文件继续增长，需要新的二级索引块

Bmap负责为文件申请新的索引块和数据块，动态维护打开文件的内存索引结构

<img src=".\assets\image-20241216165643177.png" alt="image-20241216165643177" style="zoom:80%;" />

<img src=".\assets\image-20241216165657698.png" alt="image-20241216165657698" style="zoom: 80%;" />

:star2:在做题的时候，题干：成功打开磁盘文件→inode已经进内存；系统刚启动完成→superblock已经进内存

<img src=".\assets\image-20241216165712504.png" alt="image-20241216165712504" style="zoom:80%;" />

例题：

<img src=".\assets\image-20241217135132603.png" alt="image-20241217135132603" style="zoom:50%;" />

系统刚初启完成，系统中只有pa在执行代码：证明superblock已经进内存，缓存除了pa占用的，剩下的都在自由队列，都是干净的缓存

文件大小只有5200字节，读写头移动到4500后，文件只剩余700字节，想要读入1000字节，实际读入的是700，read的返回值也就是count等于700。所以write就是在文件末尾写入700字节

（1）绘制文件的索引结构

5200/512=10余80

11个数据块，1个索引块

<img src=".\assets\image-20241217135646926.png" alt="image-20241217135646926" style="zoom:50%;" />

（2）简述open系统调用的过程

<img src=".\assets\image-20241217135804156.png" alt="image-20241217135804156" style="zoom:50%;" />

:star2:在这里也可以发现，inode初建时，i_lastr= -1，说明如果第一次读文件时是顺序读，从0号逻辑块开始读，就会满足预读的条件，把1号给预读进来

（3）

![image-20241217140013824](.\assets\image-20241217140013824.png)

只要调用seek就是随机读写，即使seek中没有改变读写指针的位置

（4）简述read 操作的读入过程

<img src=".\assets\image-20241217140223312.png" alt="image-20241217140223312" style="zoom:80%;" />

<img src=".\assets\image-20241217140326957.png" alt="image-20241217140326957" style="zoom:80%;" />

<img src=".\assets\image-20241217140352903.png" alt="image-20241217140352903" style="zoom:80%;" />

（5）简述write操作的写入过程

<img src=".\assets\image-20241217140714953.png" alt="image-20241217140714953" style="zoom:80%;" />

<img src=".\assets\image-20241222000541895.png" alt="image-20241222000541895" style="zoom:90%;" />

<img src=".\assets\image-20241217153601326.png" alt="image-20241217153601326" style="zoom:80%;" />

最后的绿字写错了，返回700-0=700，修改f_offset=m_offset=5900，修改i_size=5900

为什么要释放：

![image-20241217133308065](.\assets\image-20241217133308065.png)

可以看到释放的意义其实就在于清B_BUSY并挂到自由队尾

之前预读讲过，预读进来的块占用的缓存会被立即释放。原因就在于预读进来的块不一定未来会被使用，不能挂在设备队列里，可能会造成浪费，要直接清掉B_BUSY让它在自由队列里，如果未来真的用了再给它设置B_BUSY。

延迟写也是同样的操作，设置延迟写标志，然后直接释放，清B_BUSY并挂到自由队尾，等待被重用

那么对于写操作超过文件长度，会导致尚未分配物理块，这里的申请一个物理块，给它分配缓存，缓存清0，设置延迟写，然后把占用的缓存立即释放，就相当于单独完成了申请一个物理块的操作，没有把后续往这个块里面写的过程一起做。申请、释放之后，就相当于有对应的物理块了，再开始正常的写操作。并且因为设置了延迟写标志，所以后续重用时，不会发生先读再写，不会把物理块的原有垃圾留下。而且这样做的好处，还有一个就是，如果在刚刚被延迟写后释放的缓存一直没有被重用，走到了自由队列队头，被重新分配之前会写回磁盘，相当于把新分配的数据块磁盘内容给清空了，延迟清空。

## 文件系统的目录管理

**文件目录**对大量的文件实施有效的管理。按**文件名**对所有文件进行管理，实现**从文件符号名到文件实体的映射**。

目录管理要求：实现“按名存取”；提高目录的检索速度；文件共享；允许文件重名。

其中，允许文件重名指的是不同路径下可以重名

### 目录结构

文件控制块FCB，一个FCB就是一条目录。

<img src=".\assets\image-20241219174025850.png" alt="image-20241219174025850" style="zoom:80%;" />

目录结构：

（1）一级目录结构

<img src=".\assets\image-20241219174145972.png" alt="image-20241219174145972" style="zoom:50%;" />

就是一个线性表

①简单，可实现按名存取 

②**文件不允许重名** 

③不便于对文件进行分组管理 

④寻找目录项的过程比较冗长

（2）二级目录结构

<img src=".\assets\image-20241219174248620.png" alt="image-20241219174248620" style="zoom:50%;" />

主文件目录是按照用户存储的

①检索速度提高

②**不同用户**可以使用相同的文件名

③缺乏灵活性

（3）多级目录结构

<img src=".\assets\image-20241219174421671.png" alt="image-20241219174421671" style="zoom:50%;" />

对于图中的a，有两个文件路径：

root/db/dba/a

root/da/a（勾连）

UNIX引入i_node，如果文件名长于28字节，会只识别前28字节。

<img src=".\assets\image-20241219175138326.png" alt="image-20241219175138326" style="zoom:67%;" />

所以文件数据区和inode都是包含数据+目录的。在文件数据区，每个目录项是32字节，所以一个数据盘块512/32=16个目录项。在inode节点，inode节点的“文件类型编码”部分如果是10，代表就是目录文件。

<img src=".\assets\image-20241219180931378.png" alt="image-20241219180931378" style="zoom:67%;" />

 Inode区中的第一个inode节点，默认指向根目录文件（由全局变量rootdir指示）

<img src=".\assets\image-20241219194523732.png" alt="image-20241219194523732" style="zoom:67%;" />

<img src=".\assets\image-20241219194536423.png" alt="image-20241219194536423" style="zoom:67%;" />

首先查找根目录，1号inode，32位32位的读，每一个32位中，前28位得到文件名，后4位得到外存inode号。**在得到的inode中，用“文件类型编码”来判断是目录文件还是数据文件**，如果是目录文件，就32位32位的读，从而得到对应的下一级文件；如果是数据文件，不能32位读，而是以字符流形式读入，得到数据文件。

**同一级的所有节点，在上一级目录文件中登记**

<img src=".\assets\image-20241219195426205.png" alt="image-20241219195426205" style="zoom:67%;" />

有两个目录项，但是它们的后四位，是完全一样的号码，指向同一个inode，同一个磁盘文件。是对一个磁盘文件起了两个文件名，/a0/b15和/a0/bx0。所以link会添加新的目录项，但不会添加新的inode。

注意create和link在操作上有先后，但一旦link完成，两条路径地位就是平等的，都是指向同一个inode的目录项。不会再能区分出谁是create来的，谁是link来的。

 目录树中的**每一个节点对应一个文件**，具有**唯一的Inode**

如果是目录节点，Inode中标注为目录文件；如果是文件节点，Inode中标注为数据文件或设备文件

### 目录检索

<img src=".\assets\image-20241219195500976.png" alt="image-20241219195500976" style="zoom:67%;" />

第一个参数就是文件的路径，可以是相对路径或者绝对路径

文件“/usr/ast/mbox”的搜索过程

#### open

<img src=".\assets\image-20241219200054617.png" alt="image-20241219200054617" style="zoom:80%;" />

路径的第一个字符是/，代表是从根目录开始。先把根目录inode拿到内存里面来。32位32位的取，对前28位去和“usr：进行匹配。root不知道文件大小，读root可能就需要往内存读很多盘块，最好情况下如图，就是在读第一个盘块时，就匹配上了usr。如果把root所有盘块都读入后，也没有匹配到usr，证明该路径不存在，设置出错码。如果找到usr，进入usr去找ast，再进入ast去找mbox，步骤都同理，如下

<img src=".\assets\image-20241219200332986.png" alt="image-20241219200332986" style="zoom:80%;" />

注意这张图中的一个点是自己（usr的inode节点是6），两个点是上一级目录（root的inode节点是1）

<img src=".\assets\image-20241219200806757.png" alt="image-20241219200806757" style="zoom:67%;" />

在找mbox（也就是最后一个目录项）时，给它创建好内存，搜索结束。也就是如果open正确执行，函数返回的是创建好的inode节点，对应之前讲的，open的系统调用中打开时先目录搜索该文件是否存在，如果存在的话创建一个内存inode复制进来，这两件事都是nameI函数做的（下图的红框）

<img src=".\assets\image-20241219201541040.png" alt="image-20241219201541040" style="zoom:80%;" />

在搜索过程中，任何一级没有找到，都会导致最后函数的返回值是空，如果正确，返回的就是一个内存inode。

如果是open，那么mbox必须已经存在，能够找到，如果找不到，返回值为null。

<img src=".\assets\image-20241219201626923.png" alt="image-20241219201626923" style="zoom:50%;" />

#### delete

和open比较像，也是路径必须存在。在搜索过程中，任何一级没有找到，都会导致最后函数的返回值是空，如果正确，返回的是返回上级目录文件的内存Inode； 且m_Offset记录目录项位置

<img src=".\assets\image-20241219202200271.png" alt="image-20241219202200271" style="zoom:50%;" />

 unlink只是**取消文件的一条路径**， 取消最后一条路径时才**真正删除一个文件**

#### create

<img src=".\assets\image-20241219202542508.png" alt="image-20241219202542508" style="zoom:80%;" />

如果前面几级没找到，直接设置出错码。对于最后一级，如果没找到，是正确的，但是因为是没有找到，为了和其他保持一致，也会返回null，区别在于没有错误码，因为这是对的。没有找到的情况下，①ast的内存inode写入u_pdir（就是父一级的文件夹的位置写在user结构里面）②找到一个空闲目录项，把读写指针停在这个地方。

<img src=".\assets\image-20241219203048225.png" alt="image-20241219203048225" style="zoom:80%;" />

有出错码的空，说明是前几级路径有误，是错的。

没有出错码的空，证明是正确的。

图中的成功是指磁盘有空闲inode

如果最后一级也被找到了，处理等同于open，但文件会被全部清空：盘块全部释放掉，addr的数组全部清空，isize等于0

会把usr的内存inode做好，把ast的inode号码放进u_pdir，也就是user结构里面就能知道ast的inode号，同理mbox。也就是**如果设置了当前工作目录，UNIX会帮你把当前目录的最后一级和上一级的inode都在内存创建好并且放在user结构里**。用相对路径去搜索，会大幅节省目录检索时间。（因为目录检索的耗时就是把inode从磁盘读到内存，并进行匹配。相对路径会把当前路径之前都放进内存准备好）

### 子文件系统的挂载

文件装配块：Mount m_Mount[NMOUNT]

<img src=".\assets\image-20241219205245195.png" alt="image-20241219205245195" style="zoom:50%;" />

系统初启时的挂载，所以根目录会占用一个文件装配块 m_Mount[0]

m_spb指向文件根目录的内存superblock，文件根目录的inode会在系统初启时进内存，所以m_inodep指向文件根目录的inode

UNIX V6++一共有5个文件装配块，根目录占了一个，所以最多再插4块盘。

插入一块U盘后，把子文件系统的superblock读进内存，记入m_Mount[1]。然后把U盘mount到某个路径，比如将U盘挂载到 /mnt/usb，先找到这个路径，然后inode取进内存，记入m_Mount[1]，同时设置i_flag中的 IMOUNT标志为1，表明这是一个挂载的特殊的目录节点，不是一个普通的目录节点。

<img src=".\assets\image-20241219205649653.png" alt="image-20241219205649653" style="zoom:80%;" />

### 子文件系统上的目录检索

例：/mnt/usb/ast/Jerry

/ast/Jerry其实是在子文件系统，只不过是挂载在了/mnt/usb下面。实际上需要做两个系统的superblock切换，利用子文件系统的装配块。

在nameI过程中，如果发现内存Inode 存在，且IMOUNT被设置，证明这是一个装配点。拿到内存inode，和文件装配块去匹配m_inodep，找到后设备号m_dev就表明是哪一个设备指向了内存inode。接下来就是离开根文件系统，去向子文件系统。

<img src=".\assets\image-20241219210159919.png" alt="image-20241219210159919" style="zoom:80%;" />

注意，可以mount到目录树上的任意一个节点，任意一个位置。

windows也是一个树状的目录结构，但它是按盘符组织的（理论上和安用户组织的二级结构没有什么区别和优化）。UNIX在目录树上是根本感受不到盘符的，更加灵活。

<img src=".\assets\image-20241219212330236.png" alt="image-20241219212330236" style="zoom:80%;" />

（1）因为Tom和Temp指向的索引节点号是同一个，所以是指向同一个磁盘文件，所以占用的物理盘块号是相同的。

（2）逐级搜索匹配，创建inode的过程，见图中

（3）如果进程pa在成功打开Tom文件后，创建了子进程pb，pb上台后， 以只读的方式打开了文件Temp，请绘制出此时两个文件的内存打开结构。

<img src=".\assets\image-20241219212936218.png" alt="image-20241219212936218" style="zoom:80%;" />

<img src=".\assets\image-20241219213250751.png" alt="image-20241219213250751" style="zoom:80%;" />

tom是父进程复制给子进程的，但是temp是子进程自己open的。只要open，就会创建一个file，所以pb会创建一个只读权限的file。但是，又因为temp和file本质上是同一个磁盘文件，对于同一个磁盘文件只会创建一个inode，所以指向了同一个内存inode。 **pb可以使用两个不同的文件句柄以不同的权限不同的读写指针位置操作同一个文件**

子进程close的时候，可以用不同的文件句柄控制不同文件的关闭

（4）此后进程pa先关闭了Tom文件，然后执行了unlink(“/Temp”)， 哪些数据结构会发生变化？

<img src=".\assets\image-20241221223827637.png" alt="image-20241221223827637" style="zoom:80%;" />

注意，目录项删除之后位置就空余了，后续目录项不会前移，以后再往里面写新的目录项时，先补空位，写到temp之前占用的位置

注意，**负责撤销file结构和inode节点的是关闭文件的操作**。当一个文件被unlink时，不会当时内存inode被撤销，因为只是i_nlink（目录树上的路径数）减1，f_count还没变。要等到文件关闭的时候，**close操作才会使f_count减1变成0，内存inode撤销，写回磁盘**。

父进程删除了子进程之前打开文件的路径，但是不影响子进程对文件的使用，**因为对文件的使用都是通过文件句柄**

（5）进程pa继续执行unlink (“/usr/Tom”) 

<img src=".\assets\image-20241221231657232.png" alt="image-20241221231657232" style="zoom:80%;" />

内存Inode中的i_nlink--；虽然i_nlink减为0，但是内存打开结构还在，文件并未物理删除。待子进程关闭该文件，撤销内存Inode时，写回磁盘。

（6）如果此时内存SuperBlock副本中磁盘Inode栈和空闲盘块栈的内容 如下图所示，**子进程继续关闭两个文件**，哪些数据结构会发生变化？

<img src=".\assets\image-20241221232328424.png" alt="image-20241221232328424" style="zoom: 67%;" />

因为tom和temp的文件路径都已经没有了，所以当子进程关闭两个文件，会撤销全部内存打开结构。撤销内存inode时，发现i_nlink 减到0，则删除该文件。先释放4000号盘块，再释放10号Inode节点。

<img src=".\assets\image-20241221232609880.png" alt="image-20241221232609880" style="zoom:67%;" />

（7）子进程继续创建一个新的文件“/Hello”，并向文件中写入 “Hello”，哪些数据结构会发生变化？

<img src=".\assets\image-20241221232642927.png" alt="image-20241221232642927" style="zoom:67%;" />

<img src=".\assets\image-20241221232656480.png" alt="image-20241221232656480" style="zoom:67%;" />

:star2:**关闭文件是指针减少，unlink是i_nlink减1，把文件路径删除，file结构和inode节点被撤销取决于f_count和i_count，i_nlink减为0不影响已经打开的文件的使用，因为文件使用的是文件句柄而不是文件路径（文件名）。撤销内存inode时，发现i_nlink 减到0，则删除该文件。**

之前的题目是下面这样的，是涉及到索引块的，改成上面的题目之后不涉及索引块的问题了

（5）如果unlink(Jerry)

会真正在磁盘上删除，回收3000-3010盘块。其实Jerry还有一个索引块。比如3000-3010是数据块，3050是索引块，superblock有98个，那流程就是回收3000和3001，然后交给3002当组长，依次回收3003-3010，最后再回收3050。

（5）在unlink(Jerry)后，有一个进程create全新文件，紧接着写入helloworld

不考虑上述提的索引块，就假设刚才回收的最后一个块是3010。那么最后被回收的会最先被重新分配，因为在栈顶。所以helloworld会被写在3010里面。对于新创建的文件，addr[0]=3010，其他全是0。

